<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Guo Xudong's Blog·郭旭东的博客 – cobra</title><link>https://guoxudong.io/tags/cobra/</link><description>Recent content in cobra on Guo Xudong's Blog·郭旭东的博客</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Wed, 12 Aug 2020 16:48:34 +0800</lastBuildDate><atom:link href="https://guoxudong.io/tags/cobra/index.xml" rel="self" type="application/rss+xml"/><item><title>Post: Cobra 命令自动补全指北</title><link>https://guoxudong.io/post/cobra-shell-completions/</link><pubDate>Wed, 12 Aug 2020 16:48:34 +0800</pubDate><guid>https://guoxudong.io/post/cobra-shell-completions/</guid><description>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>用过类 Unix 系统中 Unix shell(Shell/Bash/Zsh) 的同学都应该对 &lt;kbd>TAB&lt;/kbd> 键印象深刻，因为它可以帮忙补全或提示后续的命令，用户不用记住完整的命令，只需输入前几个字符，按 &lt;kbd>TAB&lt;/kbd> 键，就会提示后续的命令供用户选择，用户体验极佳。目前流行的一些使用 Go 语言开发的 CLI 工具，如 &lt;code>kubectl&lt;/code> 和 &lt;code>helm&lt;/code>，他们也都有 &lt;code>completion&lt;/code> 也就是命令自动补全功能，通过将 &lt;code>source &amp;lt;(kubectl completion zsh)&lt;/code> 加入 &lt;code>.zshrc&lt;/code> 文件中，就可以在每次启动 shell 时自动加载自动补全脚本，之后就可以体验到与原生 shell 相同的自动补全功能了。这些 CLI 工具，都是基于 &lt;a href="https://github.com/spf13/cobra">Cobra&lt;/a> 库开发，命令自动补全功能也是该库提供的一个功能，本篇文章就来讲讲如何使用 Cobra 实现命令自动补全的。&lt;/p>
&lt;h2 id="cobra-shell-completion">Cobra Shell Completion&lt;/h2>
&lt;p>Cobra 可以作为一个 Golang 包，用来构建功能强大的命令行程序；同时也可以作为 CLI 工具，用来生成应用程序和命令文件。&lt;/p>
&lt;p>由于文本主要介绍 Cobra 的命令自动补全功能，更多内容请查阅&lt;a href="https://github.com/spf13/cobra">官网&lt;/a>。&lt;/p>
&lt;p>&lt;img src="https://tvax2.sinaimg.cn/large/ad5fbf65gy1gho68w1h0sj20tn09e0td.jpg" alt="Cobra">&lt;/p>
&lt;h3 id="基础用法">基础用法&lt;/h3>
&lt;p>Cobra 当前的最新版本为 &lt;code>v1.0.0&lt;/code>，支持生成多种 Shell 的自动补全脚本，目前支持：&lt;/p>
&lt;ul>
&lt;li>Bash&lt;/li>
&lt;li>Zsh&lt;/li>
&lt;li>Fish&lt;/li>
&lt;li>PowerShell&lt;/li>
&lt;/ul>
&lt;p>如上所述，Cobra 不但是一个功能强大的 Golang 包，还是一个 CLI 工具，可以用来生成应用程序和命令文件。使用如下命令，即可生成用于命令自动补全的代码：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ cobra add completion
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者也可以创建 &lt;code>cmd/completion.go&lt;/code> 文件，来放置用于生成命令自动补全脚本的代码：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#6ab825;font-weight:bold">var&lt;/span> completionCmd = &amp;amp;cobra.Command{
Use: &lt;span style="color:#ed9d13">&amp;#34;completion [bash|zsh|fish|powershell]&amp;#34;&lt;/span>,
Short: &lt;span style="color:#ed9d13">&amp;#34;Generate completion script&amp;#34;&lt;/span>,
Long: &lt;span style="color:#ed9d13">`To load completions:
&lt;/span>&lt;span style="color:#ed9d13">
&lt;/span>&lt;span style="color:#ed9d13">Bash:
&lt;/span>&lt;span style="color:#ed9d13">
&lt;/span>&lt;span style="color:#ed9d13">$ source &amp;lt;(yourprogram completion bash)
&lt;/span>&lt;span style="color:#ed9d13">
&lt;/span>&lt;span style="color:#ed9d13"># To load completions for each session, execute once:
&lt;/span>&lt;span style="color:#ed9d13">Linux:
&lt;/span>&lt;span style="color:#ed9d13"> $ yourprogram completion bash &amp;gt; /etc/bash_completion.d/yourprogram
&lt;/span>&lt;span style="color:#ed9d13">MacOS:
&lt;/span>&lt;span style="color:#ed9d13"> $ yourprogram completion bash &amp;gt; /usr/local/etc/bash_completion.d/yourprogram
&lt;/span>&lt;span style="color:#ed9d13">
&lt;/span>&lt;span style="color:#ed9d13">Zsh:
&lt;/span>&lt;span style="color:#ed9d13">
&lt;/span>&lt;span style="color:#ed9d13"># If shell completion is not already enabled in your environment you will need
&lt;/span>&lt;span style="color:#ed9d13"># to enable it. You can execute the following once:
&lt;/span>&lt;span style="color:#ed9d13">
&lt;/span>&lt;span style="color:#ed9d13">$ echo &amp;#34;autoload -U compinit; compinit&amp;#34; &amp;gt;&amp;gt; ~/.zshrc
&lt;/span>&lt;span style="color:#ed9d13">
&lt;/span>&lt;span style="color:#ed9d13"># To load completions for each session, execute once:
&lt;/span>&lt;span style="color:#ed9d13">$ yourprogram completion zsh &amp;gt; &amp;#34;${fpath[1]}/_yourprogram&amp;#34;
&lt;/span>&lt;span style="color:#ed9d13">
&lt;/span>&lt;span style="color:#ed9d13"># You will need to start a new shell for this setup to take effect.
&lt;/span>&lt;span style="color:#ed9d13">
&lt;/span>&lt;span style="color:#ed9d13">Fish:
&lt;/span>&lt;span style="color:#ed9d13">
&lt;/span>&lt;span style="color:#ed9d13">$ yourprogram completion fish | source
&lt;/span>&lt;span style="color:#ed9d13">
&lt;/span>&lt;span style="color:#ed9d13"># To load completions for each session, execute once:
&lt;/span>&lt;span style="color:#ed9d13">$ yourprogram completion fish &amp;gt; ~/.config/fish/completions/yourprogram.fish
&lt;/span>&lt;span style="color:#ed9d13">`&lt;/span>,
DisableFlagsInUseLine: &lt;span style="color:#6ab825;font-weight:bold">true&lt;/span>,
ValidArgs: []&lt;span style="color:#6ab825;font-weight:bold">string&lt;/span>{&lt;span style="color:#ed9d13">&amp;#34;bash&amp;#34;&lt;/span>, &lt;span style="color:#ed9d13">&amp;#34;zsh&amp;#34;&lt;/span>, &lt;span style="color:#ed9d13">&amp;#34;fish&amp;#34;&lt;/span>, &lt;span style="color:#ed9d13">&amp;#34;powershell&amp;#34;&lt;/span>},
Args: cobra.&lt;span style="color:#447fcf">ExactValidArgs&lt;/span>(&lt;span style="color:#3677a9">1&lt;/span>),
Run: &lt;span style="color:#6ab825;font-weight:bold">func&lt;/span>(cmd *cobra.Command, args []&lt;span style="color:#6ab825;font-weight:bold">string&lt;/span>) {
&lt;span style="color:#6ab825;font-weight:bold">switch&lt;/span> args[&lt;span style="color:#3677a9">0&lt;/span>] {
&lt;span style="color:#6ab825;font-weight:bold">case&lt;/span> &lt;span style="color:#ed9d13">&amp;#34;bash&amp;#34;&lt;/span>:
cmd.&lt;span style="color:#447fcf">Root&lt;/span>().&lt;span style="color:#447fcf">GenBashCompletion&lt;/span>(os.Stdout)
&lt;span style="color:#6ab825;font-weight:bold">case&lt;/span> &lt;span style="color:#ed9d13">&amp;#34;zsh&amp;#34;&lt;/span>:
cmd.&lt;span style="color:#447fcf">Root&lt;/span>().&lt;span style="color:#447fcf">GenZshCompletion&lt;/span>(os.Stdout)
&lt;span style="color:#6ab825;font-weight:bold">case&lt;/span> &lt;span style="color:#ed9d13">&amp;#34;fish&amp;#34;&lt;/span>:
cmd.&lt;span style="color:#447fcf">Root&lt;/span>().&lt;span style="color:#447fcf">GenFishCompletion&lt;/span>(os.Stdout, &lt;span style="color:#6ab825;font-weight:bold">true&lt;/span>)
&lt;span style="color:#6ab825;font-weight:bold">case&lt;/span> &lt;span style="color:#ed9d13">&amp;#34;powershell&amp;#34;&lt;/span>:
cmd.&lt;span style="color:#447fcf">Root&lt;/span>().&lt;span style="color:#447fcf">GenPowerShellCompletion&lt;/span>(os.Stdout)
}
},
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>官方推荐将生成内容输出到 &lt;code>os.Stdout&lt;/code>，只需上面这些简单的命令，即可在你的 CLI 工具中新增 &lt;code>completion&lt;/code> 子命令，执行该命令即可生成相应 Shell 的命令自动补全脚本，将其插入或保存到相应 Shell 的指定位置即可实现命令自动补全功能。&lt;/p>
&lt;div class="alert alert-warning" role="alert">
&lt;h4 class="alert-heading">注意&lt;/h4>
如果加载了配置文件，&lt;code>os.Stdout&lt;/code> 可能会打印多余的信息，这会导致自动补全脚本失效，所以请避免这种情况。
&lt;/div>
&lt;h3 id="进阶用法">进阶用法&lt;/h3>
&lt;p>上面的这些只是基本用法，完成的只是命令补全的基本功能，但一些定制化的需求是无法实现的。比如，&lt;code>kubectl get [tab]&lt;/code> 这里的预期内容是返回所有 k8s 资源名称，但是只靠上面的代码是无法实现的。这里就需要用到自定义补全，通过为每个命令增加不同的参数或方法，可以实现静态和动态补全等功能。&lt;/p>
&lt;h4 id="名称补全">名称补全&lt;/h4>
&lt;p>名称补全其实也分静态名称和动态名称，静态名称就像 &lt;code>kubectl completion [tab]&lt;/code> 预期返回的多种 shell 名称，内容为事先在代码中已经定义好的内容；而动态名称，就是像 &lt;code>helm status [tab]&lt;/code> 预期返回的所有 release 名称，并不是以静态内容体现，而是通过函数动态获取的内容。&lt;/p>
&lt;h5 id="静态名称补全">静态名称补全&lt;/h5>
&lt;p>静态名称补全比较简单，只要在想要自动补全的子命令中加入 &lt;code>ValidArgs&lt;/code> 字段，传入一组包含预期结果的字符串数组即可，代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">validArgs []&lt;span style="color:#6ab825;font-weight:bold">string&lt;/span> = { &lt;span style="color:#ed9d13">&amp;#34;pod&amp;#34;&lt;/span>, &lt;span style="color:#ed9d13">&amp;#34;node&amp;#34;&lt;/span>, &lt;span style="color:#ed9d13">&amp;#34;service&amp;#34;&lt;/span>, &lt;span style="color:#ed9d13">&amp;#34;replicationcontroller&amp;#34;&lt;/span> }
cmd := &amp;amp;cobra.Command{
Use: &lt;span style="color:#ed9d13">&amp;#34;get [(-o|--output=)json|yaml|template|...] (RESOURCE [NAME] | RESOURCE/NAME ...)&amp;#34;&lt;/span>,
Short: &lt;span style="color:#ed9d13">&amp;#34;Display one or many resources&amp;#34;&lt;/span>,
Long: get_long,
Example: get_example,
Run: &lt;span style="color:#6ab825;font-weight:bold">func&lt;/span>(cmd *cobra.Command, args []&lt;span style="color:#6ab825;font-weight:bold">string&lt;/span>) {
err := &lt;span style="color:#447fcf">RunGet&lt;/span>(f, out, cmd, args)
util.&lt;span style="color:#447fcf">CheckErr&lt;/span>(err)
},
ValidArgs: validArgs,
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里是模仿 kubectl 的 &lt;code>get&lt;/code> 子命令，在执行该命令时效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ kubectl get [tab][tab]
node pod replicationcontroller service
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果命令有别名（Aliases）的话，则可以使用 &lt;code>ArgAliases&lt;/code>，代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">argAliases []&lt;span style="color:#6ab825;font-weight:bold">string&lt;/span> = { &lt;span style="color:#ed9d13">&amp;#34;pods&amp;#34;&lt;/span>, &lt;span style="color:#ed9d13">&amp;#34;nodes&amp;#34;&lt;/span>, &lt;span style="color:#ed9d13">&amp;#34;services&amp;#34;&lt;/span>, &lt;span style="color:#ed9d13">&amp;#34;svc&amp;#34;&lt;/span>, &lt;span style="color:#ed9d13">&amp;#34;replicationcontrollers&amp;#34;&lt;/span>, &lt;span style="color:#ed9d13">&amp;#34;rc&amp;#34;&lt;/span> }
cmd := &amp;amp;cobra.Command{
...
ValidArgs: validArgs,
ArgAliases: argAliases
}
&lt;/code>&lt;/pre>&lt;/div>
&lt;div class="alert alert-warning" role="alert">
&lt;h4 class="alert-heading">注意&lt;/h4>
别名不会在按 &lt;kbd>TAB&lt;/kbd> 时提示给用户，但如果手动输入，则补全算法会将其视为有效参数，并提供后续的补全。
&lt;/div>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ kubectl get rc [tab][tab]
backend frontend database
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里如果不声明 &lt;code>rc&lt;/code> 为别名，则补全算法将无法补全后续的内容。&lt;/p>
&lt;h5 id="动态名称补全">动态名称补全&lt;/h5>
&lt;p>如果需要补全的名称是动态生成的，例如 &lt;code>helm status [tab]&lt;/code> 这里的 &lt;code>release&lt;/code> 值，就需要用到 &lt;code>ValidArgsFunction&lt;/code> 字段，将需要返回的内容以 function 的形式声明在 &lt;code>cobra.Command&lt;/code> 中，代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">cmd := &amp;amp;cobra.Command{
Use: &lt;span style="color:#ed9d13">&amp;#34;status RELEASE_NAME&amp;#34;&lt;/span>,
Short: &lt;span style="color:#ed9d13">&amp;#34;Display the status of the named release&amp;#34;&lt;/span>,
Long: status_long,
RunE: &lt;span style="color:#6ab825;font-weight:bold">func&lt;/span>(cmd *cobra.Command, args []&lt;span style="color:#6ab825;font-weight:bold">string&lt;/span>) {
&lt;span style="color:#447fcf">RunGet&lt;/span>(args[&lt;span style="color:#3677a9">0&lt;/span>])
},
ValidArgsFunction: &lt;span style="color:#6ab825;font-weight:bold">func&lt;/span>(cmd *cobra.Command, args []&lt;span style="color:#6ab825;font-weight:bold">string&lt;/span>, toComplete &lt;span style="color:#6ab825;font-weight:bold">string&lt;/span>) ([]&lt;span style="color:#6ab825;font-weight:bold">string&lt;/span>, cobra.ShellCompDirective) {
&lt;span style="color:#6ab825;font-weight:bold">if&lt;/span> &lt;span style="color:#24909d">len&lt;/span>(args) != &lt;span style="color:#3677a9">0&lt;/span> {
&lt;span style="color:#6ab825;font-weight:bold">return&lt;/span> &lt;span style="color:#6ab825;font-weight:bold">nil&lt;/span>, cobra.ShellCompDirectiveNoFileComp
}
&lt;span style="color:#6ab825;font-weight:bold">return&lt;/span> &lt;span style="color:#447fcf">getReleasesFromCluster&lt;/span>(toComplete), cobra.ShellCompDirectiveNoFileComp
},
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面这段代码是 &lt;code>helm&lt;/code> 的源码，也是 Cobra 的官方示例代码，很好的展示了这个 function 的结构及返回格式，有兴趣的同学可以去看一下 &lt;code>helm&lt;/code> 的源码，也是很有意思的。&lt;code>getReleasesFromCluster&lt;/code> 方法是用来获取 Helm release 列表，在执行命令时，效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ helm status [tab][tab]
harbor notary rook thanos
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>cobra.ShellCompDirective&lt;/code> 可以控制自动补全的特定行为，你可以用或运算符来组合它们，像这样 &lt;code>cobra.ShellCompDirectiveNoSpace | cobra.ShellCompDirectiveNoFileComp&lt;/code>，下面是它们的介绍（摘自官方文档）：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#999;font-style:italic">// Indicates that the shell will perform its default behavior after completions
&lt;/span>&lt;span style="color:#999;font-style:italic">// have been provided (this implies none of the other directives).
&lt;/span>&lt;span style="color:#999;font-style:italic">&lt;/span>ShellCompDirectiveDefault
&lt;span style="color:#999;font-style:italic">// Indicates an error occurred and completions should be ignored.
&lt;/span>&lt;span style="color:#999;font-style:italic">&lt;/span>ShellCompDirectiveError
&lt;span style="color:#999;font-style:italic">// Indicates that the shell should not add a space after the completion,
&lt;/span>&lt;span style="color:#999;font-style:italic">// even if there is a single completion provided.
&lt;/span>&lt;span style="color:#999;font-style:italic">&lt;/span>ShellCompDirectiveNoSpace
&lt;span style="color:#999;font-style:italic">// Indicates that the shell should not provide file completion even when
&lt;/span>&lt;span style="color:#999;font-style:italic">// no completion is provided.
&lt;/span>&lt;span style="color:#999;font-style:italic">&lt;/span>ShellCompDirectiveNoFileComp
&lt;span style="color:#999;font-style:italic">// Indicates that the returned completions should be used as file extension filters.
&lt;/span>&lt;span style="color:#999;font-style:italic">// For example, to complete only files of the form *.json or *.yaml:
&lt;/span>&lt;span style="color:#999;font-style:italic">// return []string{&amp;#34;yaml&amp;#34;, &amp;#34;json&amp;#34;}, ShellCompDirectiveFilterFileExt
&lt;/span>&lt;span style="color:#999;font-style:italic">// For flags, using MarkFlagFilename() and MarkPersistentFlagFilename()
&lt;/span>&lt;span style="color:#999;font-style:italic">// is a shortcut to using this directive explicitly.
&lt;/span>&lt;span style="color:#999;font-style:italic">//
&lt;/span>&lt;span style="color:#999;font-style:italic">&lt;/span>ShellCompDirectiveFilterFileExt
&lt;span style="color:#999;font-style:italic">// Indicates that only directory names should be provided in file completion.
&lt;/span>&lt;span style="color:#999;font-style:italic">// For example:
&lt;/span>&lt;span style="color:#999;font-style:italic">// return nil, ShellCompDirectiveFilterDirs
&lt;/span>&lt;span style="color:#999;font-style:italic">// For flags, using MarkFlagDirname() is a shortcut to using this directive explicitly.
&lt;/span>&lt;span style="color:#999;font-style:italic">//
&lt;/span>&lt;span style="color:#999;font-style:italic">// To request directory names within another directory, the returned completions
&lt;/span>&lt;span style="color:#999;font-style:italic">// should specify a single directory name within which to search. For example,
&lt;/span>&lt;span style="color:#999;font-style:italic">// to complete directories within &amp;#34;themes/&amp;#34;:
&lt;/span>&lt;span style="color:#999;font-style:italic">// return []string{&amp;#34;themes&amp;#34;}, ShellCompDirectiveFilterDirs
&lt;/span>&lt;span style="color:#999;font-style:italic">//
&lt;/span>&lt;span style="color:#999;font-style:italic">&lt;/span>ShellCompDirectiveFilterDirs
&lt;/code>&lt;/pre>&lt;/div>
&lt;div class="alert alert-warning" role="alert">
&lt;h4 class="alert-heading">注意&lt;/h4>
&lt;code>ValidArgs&lt;/code> 和 &lt;code>ValidArgsFunction&lt;/code> 同时只能存在一个。在使用 &lt;code>ValidArgsFunction&lt;/code> 时，Cobra 将在解析了命令行中提供的所有 flag 和参数之后才会调用您的注册函数。
&lt;/div>
&lt;h4 id="flag-补全">Flag 补全&lt;/h4>
&lt;h5 id="指定必选-flag">指定必选 flag&lt;/h5>
&lt;p>大多时候，名字补全只会提示子命令的补全，但如果一些 flag 是必须的，也可以在用户按 &lt;kbd>TAB&lt;/kbd> 键时进行自动补全，代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">cmd.&lt;span style="color:#447fcf">MarkFlagRequired&lt;/span>(&lt;span style="color:#ed9d13">&amp;#34;pod&amp;#34;&lt;/span>)
cmd.&lt;span style="color:#447fcf">MarkFlagRequired&lt;/span>(&lt;span style="color:#ed9d13">&amp;#34;container&amp;#34;&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后在执行命令时，就可以看到：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ kubectl &lt;span style="color:#24909d">exec&lt;/span> [tab][tab]
-c --container= -p --pod=
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="动态-flag">动态 flag&lt;/h5>
&lt;p>同名称补全类似，Cobra 提供了一个字段来完成该功能，需要使用 &lt;code>command.RegisterFlagCompletionFunc()&lt;/code> 来注册自动补全的函数，代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">flagName := &lt;span style="color:#ed9d13">&amp;#34;output&amp;#34;&lt;/span>
cmd.&lt;span style="color:#447fcf">RegisterFlagCompletionFunc&lt;/span>(flagName, &lt;span style="color:#6ab825;font-weight:bold">func&lt;/span>(cmd *cobra.Command, args []&lt;span style="color:#6ab825;font-weight:bold">string&lt;/span>, toComplete &lt;span style="color:#6ab825;font-weight:bold">string&lt;/span>) ([]&lt;span style="color:#6ab825;font-weight:bold">string&lt;/span>, cobra.ShellCompDirective) {
&lt;span style="color:#6ab825;font-weight:bold">return&lt;/span> []&lt;span style="color:#6ab825;font-weight:bold">string&lt;/span>{&lt;span style="color:#ed9d13">&amp;#34;json&amp;#34;&lt;/span>, &lt;span style="color:#ed9d13">&amp;#34;table&amp;#34;&lt;/span>, &lt;span style="color:#ed9d13">&amp;#34;yaml&amp;#34;&lt;/span>}, cobra.ShellCompDirectiveDefault
})
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>RegisterFlagCompletionFunc()&lt;/code> 是通过 &lt;code>command&lt;/code> 与该 flag 的进行关联的，在本示例中可以看到：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ helm status --output [tab][tab]
json table yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用方式和名称补全相同，这里就不做详细介绍了。&lt;/p>
&lt;h4 id="debug">Debug&lt;/h4>
&lt;p>命令自动补全与其他功能不同，调试起来比较麻烦，所以 Cobra 提供了调用隐藏命令，模拟自动补全脚本的方式来帮助调试代码，你可以直接使用以下隐藏命令来模拟触发：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ helm __complete status har[ENTER]
harbor
:4
Completion ended with directive: ShellCompDirectiveNoFileComp &lt;span style="color:#999;font-style:italic"># This is on stderr&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>
&lt;div class="alert alert-warning" role="alert">
&lt;h4 class="alert-heading">注意&lt;/h4>
如果需要提示名称而非补全（就是输入命令后直接按 &lt;kbd>TAB&lt;/kbd> 键），则必须将空参数传递给 &lt;code>__complete&lt;/code> 命令：
&lt;/div>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ helm __complete status &lt;span style="color:#ed9d13">&amp;#34;&amp;#34;&lt;/span>[ENTER]
harbor
notary
rook
thanos
:4
Completion ended with directive: ShellCompDirectiveNoFileComp &lt;span style="color:#999;font-style:italic"># This is on stderr&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>同样可以用来调试 flag 的自动补全：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ helm __complete status --output &lt;span style="color:#ed9d13">&amp;#34;&amp;#34;&lt;/span>[ENTER]
json
table
yaml
:4
Completion ended with directive: ShellCompDirectiveNoFileComp &lt;span style="color:#999;font-style:italic"># This is on stderr&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="结语">结语&lt;/h2>
&lt;p>以上内容是作者挑选的一些较为常用的功能，更多的内容详见&lt;a href="https://github.com/spf13/cobra">官方文档&lt;/a>。如果想看示例的话，推荐 &lt;a href="https://github.com/kubernetes/kubectl">kubectl&lt;/a> 和 &lt;a href="https://github.com/helm/helm">helm&lt;/a> 的源码。&lt;/p>
&lt;p>当然 Cobra 还不是完美的，比如生成的 Zsh 脚本有些问题，&lt;code>kubectl&lt;/code> 和 &lt;code>helm&lt;/code> 都是使用将其生成的 Bash 自动补全脚本转化为 Zsh 的自动补全脚本的方式。但不得不承认，Cobra 是一个非常好用的 CLI 工具构建框架，很多流行的 CLI 工具都是使用它来构建的，这也是为什么使用 GO 语言编写的 CLI 工具如雨后春笋般快速的出现并占据了云原生工具的关键位置。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/spf13/cobra">Cobra - github.com&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>