<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Guo Xudong&#39;s Blog·郭旭东的博客 – 图解 k8s</title>
    <link>https://guoxudong.io/tags/%E5%9B%BE%E8%A7%A3-k8s/</link>
    <description>Recent content in 图解 k8s on Guo Xudong&#39;s Blog·郭旭东的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Mon, 28 Sep 2020 15:00:38 +0800</lastBuildDate>
    
	  <atom:link href="https://guoxudong.io/tags/%E5%9B%BE%E8%A7%A3-k8s/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Post: 图解 K8S 源码 - Deployment Controller 篇</title>
      <link>https://guoxudong.io/post/diagrams-k8s-src-deployment-controller/</link>
      <pubDate>Mon, 28 Sep 2020 15:00:38 +0800</pubDate>
      
      <guid>https://guoxudong.io/post/diagrams-k8s-src-deployment-controller/</guid>
      <description>
        
        
        &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;Kubernetes 最为云原生领域的绝对 leader，可以说是当下最著名开源项目之一，拥有着庞大的贡献者群体以及更庞大的用户群体。作为使用 Go 语言开发的明星项目，其源码也是非常有趣的。笔者在研究 Kubernetes 源码时，常常发现很多让人眼前一亮的设计和拍案叫绝的逻辑。但由于 Kubernetes 的代码量十分庞大，函数间的调用也十分复杂，在阅读源码时常常被绕的找不着北，正好手边有一本《图解算法》，于是就萌生了图解 Kubernetes 源码的想法。本文为本系列第一篇文章，尝试使用流程图来分析 Kubernetes Controller Manager 中 的 Deployment Controller 逻辑。&lt;/p&gt;
&lt;h2 id=&#34;deployment-controller&#34;&gt;Deployment Controller&lt;/h2&gt;
&lt;p&gt;Deployment Controller 是 Kube-Controller-Manager 中最常用的 Controller 之一管理 Deployment 资源。而 Deployment 的本质就是通过管理 ReplicaSet 和 Pod 在 Kubernetes 集群中部署 &lt;strong&gt;无状态&lt;/strong&gt; Workload。&lt;/p&gt;
&lt;h3 id=&#34;deploymentreplicaset-和-pod&#34;&gt;Deployment、ReplicaSet 和 Pod&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax4.sinaimg.cn/large/ad5fbf65gy1gj6twofn24j20es09s43a.jpg&#34; alt=&#34;deployment-controller&#34;&gt;&lt;/p&gt;
&lt;p&gt;Deployment 通过控制 ReplicaSet，ReplicaSet 再控制 Pod，最终由 Controller 驱动达到期望状态。在控制器模式下，每次操作对象都会触发一次事件，然后 controller 会进行一次 syncLoop 操作，controller 是通过 informer 监听事件以及进行 ListWatch 操作的。&lt;/p&gt;
&lt;p&gt;Deployment Controller 会监听 DeploymentInformer、ReplicaSetInformer、PodInformer 三种资源。这三种资源变化时，都会触发 syncLoop 也就是下面代码 &lt;code&gt;dc.Run()&lt;/code&gt; 中的 &lt;code&gt;dc.syncDeployment&lt;/code&gt; 操作，来进行状态更新逻辑。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;startDeploymentController&lt;/span&gt;(ctx ControllerContext) (http.Handler, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;bool&lt;/span&gt;, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;error&lt;/span&gt;) {
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; !ctx.AvailableResources[schema.GroupVersionResource{Group: &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;apps&amp;#34;&lt;/span&gt;, Version: &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;v1&amp;#34;&lt;/span&gt;, Resource: &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;deployments&amp;#34;&lt;/span&gt;}] {
      &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;false&lt;/span&gt;, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;nil&lt;/span&gt;
    }
    dc, err := deployment.&lt;span style=&#34;color:#447fcf&#34;&gt;NewDeploymentController&lt;/span&gt;(
      ctx.InformerFactory.&lt;span style=&#34;color:#447fcf&#34;&gt;Apps&lt;/span&gt;().&lt;span style=&#34;color:#447fcf&#34;&gt;V1&lt;/span&gt;().&lt;span style=&#34;color:#447fcf&#34;&gt;Deployments&lt;/span&gt;(),
      ctx.InformerFactory.&lt;span style=&#34;color:#447fcf&#34;&gt;Apps&lt;/span&gt;().&lt;span style=&#34;color:#447fcf&#34;&gt;V1&lt;/span&gt;().&lt;span style=&#34;color:#447fcf&#34;&gt;ReplicaSets&lt;/span&gt;(),
      ctx.InformerFactory.&lt;span style=&#34;color:#447fcf&#34;&gt;Core&lt;/span&gt;().&lt;span style=&#34;color:#447fcf&#34;&gt;V1&lt;/span&gt;().&lt;span style=&#34;color:#447fcf&#34;&gt;Pods&lt;/span&gt;(),
      ctx.ClientBuilder.&lt;span style=&#34;color:#447fcf&#34;&gt;ClientOrDie&lt;/span&gt;(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;deployment-controller&amp;#34;&lt;/span&gt;),
    )
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
      &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;true&lt;/span&gt;, fmt.&lt;span style=&#34;color:#447fcf&#34;&gt;Errorf&lt;/span&gt;(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;error creating Deployment controller: %v&amp;#34;&lt;/span&gt;, err)
    }
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;go&lt;/span&gt; dc.&lt;span style=&#34;color:#447fcf&#34;&gt;Run&lt;/span&gt;(&lt;span style=&#34;color:#24909d&#34;&gt;int&lt;/span&gt;(ctx.ComponentConfig.DeploymentController.ConcurrentDeploymentSyncs), ctx.Stop)
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;true&lt;/span&gt;, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;nil&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;deployment-controller-启动流程&#34;&gt;Deployment Controller 启动流程&lt;/h3&gt;
&lt;p&gt;那么先从启动逻辑开始，Kube-Controller-Manager 中所有的 Controller 的启动逻辑都差不多，都是在 &lt;code&gt;Run()&lt;/code&gt; 方法中完成初始化并启动，&lt;code&gt;NewControllerInitializers&lt;/code&gt; 会初始化所有 Controller，而 &lt;code&gt;startXXXXController()&lt;/code&gt; 则会启动对应的 Controller。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva3.sinaimg.cn/large/ad5fbf65gy1gj6rw439nrj20mh12o7wh.jpg&#34; alt=&#34;deployment-controller-启动流程&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;核心逻辑-synchandler&#34;&gt;核心逻辑 syncHandler&lt;/h3&gt;
&lt;p&gt;Deployment Controller 在初始化时指定了 &lt;code&gt;dc.syncHandler = dc.syncDeployment&lt;/code&gt;，所以核心逻辑就是围绕 &lt;code&gt;syncDeployment()&lt;/code&gt; 来展开的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax4.sinaimg.cn/large/ad5fbf65gy1gj6s4tfuynj20my1zq7wi.jpg&#34; alt=&#34;deployment-controller-核心逻辑&#34;&gt;&lt;/p&gt;
&lt;p&gt;从源码可以看出，删除、暂停、回滚、扩缩容、更新策略的优先级为 &lt;code&gt;delete &amp;gt; pause &amp;gt; rollback &amp;gt; scale &amp;gt; rollout&lt;/code&gt;。而最终都不是直接更新或修改对应资源，而是通过 &lt;code&gt;dc.client.AppsV1().Deployments().UpdateStatus()&lt;/code&gt; 更新 Deployment Status。&lt;/p&gt;
&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;
&lt;p&gt;以上就是 Deployment Controller 代码逻辑，通过流程图，希望能描述的更加清晰。因为是第一次尝试图解，可能有遗漏和不足，欢迎留言指正。图解 Kubernetes 源码将作为一个系列继续下去，后续会带来更多的源码图解。&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
