<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Guo Xudong's Blog·郭旭东的博客 – operator</title><link>https://guoxudong.io/tags/operator/</link><description>Recent content in operator on Guo Xudong's Blog·郭旭东的博客</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Fri, 11 Sep 2020 08:47:51 +0800</lastBuildDate><atom:link href="https://guoxudong.io/tags/operator/index.xml" rel="self" type="application/rss+xml"/><item><title>Post: 熟悉又陌生的 k8s 字段：finalizers</title><link>https://guoxudong.io/post/k8s-gc-finalizers/</link><pubDate>Fri, 11 Sep 2020 08:47:51 +0800</pubDate><guid>https://guoxudong.io/post/k8s-gc-finalizers/</guid><description>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>经常操作 Kubernetes 集群的同学肯定对 &lt;code>finalizers&lt;/code> 字段不陌生，每当删除 namespace 或 pod 等一些 Kubernetes 资源时，有时资源状态会卡在 &lt;code>Terminating&lt;/code>，很长时间无法删除，甚至有时增加 &lt;code>--force&lt;/code> flag 之后还是无法正常删除。这时就需要 &lt;code>edit&lt;/code> 该资源，将 &lt;code>finalizers&lt;/code> 字段设置为 []，之后 Kubernetes 资源就正常删除了。&lt;/p>
&lt;p>这是一个比较常见的操作，但是当有人问 &lt;code>finalizers&lt;/code> 字段的作用是什么的时候，我是懵逼的，我甚至不知道这个熟悉又陌生的单词怎么读！那么这篇文章就来探索一下 &lt;code>finalizers&lt;/code> 这个字段到底是做什么的，在实践中应该怎么应用这个字段。（另外，这个单词读作 &lt;strong>[&amp;lsquo;faɪnəlaɪzər]&lt;/strong>）&lt;/p>
&lt;h2 id="finalizers">Finalizers&lt;/h2>
&lt;p>Finalizers 字段属于 Kubernetes GC 垃圾收集器，是一种删除拦截机制，能够让控制器实现异步的删除前（Pre-delete）回调。其存在于任何一个资源对象的 &lt;a href="https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/types.go#L246">Meta&lt;/a> 中，在 k8s 源码中声明为 &lt;code>[]string&lt;/code>，该 Slice 的内容为需要执行的拦截器名称。&lt;/p>
&lt;p>对带有 Finalizer 的对象的第一个删除请求会为其 &lt;code>metadata.deletionTimestamp&lt;/code> 设置一个值，但不会真的删除对象。一旦此值被设置，finalizers 列表中的值就&lt;strong>只能&lt;/strong>被移除。&lt;/p>
&lt;p>当 &lt;code>metadata.deletionTimestamp&lt;/code> 字段被设置时，负责监测该对象的各个控制器会通过&lt;strong>轮询&lt;/strong>对该对象的更新请求来执行它们所要处理的所有 Finalizer。 当所有 Finalizer 都被执行过，资源被删除。&lt;/p>
&lt;p>&lt;code>metadata.deletionGracePeriodSeconds&lt;/code> 的取值控制对更新的轮询周期。&lt;/p>
&lt;p>每个控制器要负责将其 Finalizer 从列表中去除。&lt;/p>
&lt;p>每执行完一个就从 &lt;code>finalizers&lt;/code> 中移除一个，直到 &lt;code>finalizers&lt;/code> 为空，之后其宿主资源才会被真正的删除。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#999;font-style:italic">// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
&lt;/span>&lt;span style="color:#999;font-style:italic">// field is set by the server when a graceful deletion is requested by the user, and is not
&lt;/span>&lt;span style="color:#999;font-style:italic">// directly settable by a client. The resource is expected to be deleted (no longer visible
&lt;/span>&lt;span style="color:#999;font-style:italic">// from resource lists, and not reachable by name) after the time in this field, once the
&lt;/span>&lt;span style="color:#999;font-style:italic">// finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
&lt;/span>&lt;span style="color:#999;font-style:italic">// Once the deletionTimestamp is set, this value may not be unset or be set further into the
&lt;/span>&lt;span style="color:#999;font-style:italic">// future, although it may be shortened or the resource may be deleted prior to this time.
&lt;/span>&lt;span style="color:#999;font-style:italic">// For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
&lt;/span>&lt;span style="color:#999;font-style:italic">// by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
&lt;/span>&lt;span style="color:#999;font-style:italic">// the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
&lt;/span>&lt;span style="color:#999;font-style:italic">// remove the pod from the API. In the presence of network partitions, this object may still
&lt;/span>&lt;span style="color:#999;font-style:italic">// exist after this timestamp, until an administrator or automated process can determine the
&lt;/span>&lt;span style="color:#999;font-style:italic">// resource is fully terminated.
&lt;/span>&lt;span style="color:#999;font-style:italic">// If not set, graceful deletion of the object has not been requested.
&lt;/span>&lt;span style="color:#999;font-style:italic">//
&lt;/span>&lt;span style="color:#999;font-style:italic">// Populated by the system when a graceful deletion is requested.
&lt;/span>&lt;span style="color:#999;font-style:italic">// Read-only.
&lt;/span>&lt;span style="color:#999;font-style:italic">// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
&lt;/span>&lt;span style="color:#999;font-style:italic">// +optional
&lt;/span>&lt;span style="color:#999;font-style:italic">&lt;/span>DeletionTimestamp *Time &lt;span style="color:#ed9d13">`json:&amp;#34;deletionTimestamp,omitempty&amp;#34; protobuf:&amp;#34;bytes,9,opt,name=deletionTimestamp&amp;#34;`&lt;/span>
&lt;span style="color:#999;font-style:italic">// Number of seconds allowed for this object to gracefully terminate before
&lt;/span>&lt;span style="color:#999;font-style:italic">// it will be removed from the system. Only set when deletionTimestamp is also set.
&lt;/span>&lt;span style="color:#999;font-style:italic">// May only be shortened.
&lt;/span>&lt;span style="color:#999;font-style:italic">// Read-only.
&lt;/span>&lt;span style="color:#999;font-style:italic">// +optional
&lt;/span>&lt;span style="color:#999;font-style:italic">&lt;/span>DeletionGracePeriodSeconds *&lt;span style="color:#6ab825;font-weight:bold">int64&lt;/span> &lt;span style="color:#ed9d13">`json:&amp;#34;deletionGracePeriodSeconds,omitempty&amp;#34; protobuf:&amp;#34;varint,10,opt,name=deletionGracePeriodSeconds&amp;#34;`&lt;/span>
&lt;span style="color:#999;font-style:italic">// Must be empty before the object is deleted from the registry. Each entry
&lt;/span>&lt;span style="color:#999;font-style:italic">// is an identifier for the responsible component that will remove the entry
&lt;/span>&lt;span style="color:#999;font-style:italic">// from the list. If the deletionTimestamp of the object is non-nil, entries
&lt;/span>&lt;span style="color:#999;font-style:italic">// in this list can only be removed.
&lt;/span>&lt;span style="color:#999;font-style:italic">// Finalizers may be processed and removed in any order. Order is NOT enforced
&lt;/span>&lt;span style="color:#999;font-style:italic">// because it introduces significant risk of stuck finalizers.
&lt;/span>&lt;span style="color:#999;font-style:italic">// finalizers is a shared field, any actor with permission can reorder it.
&lt;/span>&lt;span style="color:#999;font-style:italic">// If the finalizer list is processed in order, then this can lead to a situation
&lt;/span>&lt;span style="color:#999;font-style:italic">// in which the component responsible for the first finalizer in the list is
&lt;/span>&lt;span style="color:#999;font-style:italic">// waiting for a signal (field value, external system, or other) produced by a
&lt;/span>&lt;span style="color:#999;font-style:italic">// component responsible for a finalizer later in the list, resulting in a deadlock.
&lt;/span>&lt;span style="color:#999;font-style:italic">// Without enforced ordering finalizers are free to order amongst themselves and
&lt;/span>&lt;span style="color:#999;font-style:italic">// are not vulnerable to ordering changes in the list.
&lt;/span>&lt;span style="color:#999;font-style:italic">// +optional
&lt;/span>&lt;span style="color:#999;font-style:italic">// +patchStrategy=merge
&lt;/span>&lt;span style="color:#999;font-style:italic">&lt;/span>Finalizers []&lt;span style="color:#6ab825;font-weight:bold">string&lt;/span> &lt;span style="color:#ed9d13">`json:&amp;#34;finalizers,omitempty&amp;#34; patchStrategy:&amp;#34;merge&amp;#34; protobuf:&amp;#34;bytes,14,rep,name=finalizers&amp;#34;`&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="在-operator-中的应用">在 Operator 中的应用&lt;/h2>
&lt;p>知道了 Finalizers 是什么，那么当然也要知道怎么用 Finalizers 了。在实际开发 Operator 时，删除前（Pre-delete）回调是一个比较常见的功能，用于处理一些在资源删除前需要处理的逻辑，如：关联资源释放、释放资源通知、相关数据清理，甚至是阻止资源删除。一般 Finalizers 的处理也是会 &lt;code>Reconcile&lt;/code> 中实现的，下面就使用 &lt;a href="https://github.com/chaosblade-io/chaosblade-operator">chaosblade-operator&lt;/a> 中的源码，简单介绍一些 Finalizers 的使用方式。&lt;/p>
&lt;p>首先要了解的是 ChaosBlade-Operator 的工作原理：每个实验都会以 CR 的形式部署到 k8s 集群中，之后由 &lt;code>chaosblade-operator&lt;/code> 来操作以 DaemonSet 形式部署 &lt;code>chaosblade-tool&lt;/code> 对具体资源进行混沌实验。停止实验只需删除对应 CR 即可，在删除 CR 时，首先会执行一遍实验恢复逻辑，之后才会将 CR 删除。但如果恢复实验失败，则会将 CR 的 &lt;code>Phase&lt;/code> 设置为 &lt;code>Destroying&lt;/code>，而在 &lt;code>Reconcile&lt;/code> 中观测到 &lt;code>Phase&lt;/code> 状态为 &lt;code>Destroying&lt;/code> 或者 &lt;code>metadata.deletionTimestamp&lt;/code> 不为空时，就会不会移除 &lt;code>finalizers&lt;/code> 中的拦截器名称，阻止该 CR 被删除。&lt;/p>
&lt;p>这样设计的目的是为了在实验恢复失败后，让用户去主动查看实验恢复失败原因，如果是一些意外原因导致的实验恢复失败，及时去处理。在确认原因后，可使用 CLI 工具增加 &lt;code>--force-remove&lt;/code> 进去强制删除，项目维护者在 &lt;a href="https://github.com/chaosblade-io/chaosblade/issues/368">Issue#368&lt;/a> 中也就这个设计给出了解答。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#999;font-style:italic">// pkg/controller/chaosblade/controller.go 部分源码
&lt;/span>&lt;span style="color:#999;font-style:italic">&lt;/span>...
&lt;span style="color:#6ab825;font-weight:bold">const&lt;/span> chaosbladeFinalizer = &lt;span style="color:#ed9d13">&amp;#34;finalizer.chaosblade.io&amp;#34;&lt;/span>
...
&lt;span style="color:#6ab825;font-weight:bold">func&lt;/span> (r *ReconcileChaosBlade) &lt;span style="color:#447fcf">Reconcile&lt;/span>(request reconcile.Request) (reconcile.Result, &lt;span style="color:#6ab825;font-weight:bold">error&lt;/span>) {
reqLogger := logrus.&lt;span style="color:#447fcf">WithField&lt;/span>(&lt;span style="color:#ed9d13">&amp;#34;Request.Name&amp;#34;&lt;/span>, request.Name)
forget := reconcile.Result{}
&lt;span style="color:#999;font-style:italic">// Fetch the RC instance
&lt;/span>&lt;span style="color:#999;font-style:italic">&lt;/span> cb := &amp;amp;v1alpha1.ChaosBlade{}
err := r.client.&lt;span style="color:#447fcf">Get&lt;/span>(context.&lt;span style="color:#447fcf">TODO&lt;/span>(), request.NamespacedName, cb)
&lt;span style="color:#6ab825;font-weight:bold">if&lt;/span> err != &lt;span style="color:#6ab825;font-weight:bold">nil&lt;/span> {
&lt;span style="color:#6ab825;font-weight:bold">return&lt;/span> forget, &lt;span style="color:#6ab825;font-weight:bold">nil&lt;/span>
}
&lt;span style="color:#6ab825;font-weight:bold">if&lt;/span> &lt;span style="color:#24909d">len&lt;/span>(cb.Spec.Experiments) == &lt;span style="color:#3677a9">0&lt;/span> {
&lt;span style="color:#6ab825;font-weight:bold">return&lt;/span> forget, &lt;span style="color:#6ab825;font-weight:bold">nil&lt;/span>
}
&lt;span style="color:#999;font-style:italic">// Destroyed-&amp;gt;delete
&lt;/span>&lt;span style="color:#999;font-style:italic">&lt;/span> &lt;span style="color:#999;font-style:italic">// Remove the Finalizer if the CR object status is destroyed to delete it
&lt;/span>&lt;span style="color:#999;font-style:italic">&lt;/span> &lt;span style="color:#6ab825;font-weight:bold">if&lt;/span> cb.Status.Phase == v1alpha1.ClusterPhaseDestroyed {
cb.&lt;span style="color:#447fcf">SetFinalizers&lt;/span>(&lt;span style="color:#447fcf">remove&lt;/span>(cb.&lt;span style="color:#447fcf">GetFinalizers&lt;/span>(), chaosbladeFinalizer))
err := r.client.&lt;span style="color:#447fcf">Update&lt;/span>(context.&lt;span style="color:#447fcf">TODO&lt;/span>(), cb)
&lt;span style="color:#6ab825;font-weight:bold">if&lt;/span> err != &lt;span style="color:#6ab825;font-weight:bold">nil&lt;/span> {
reqLogger.&lt;span style="color:#447fcf">WithError&lt;/span>(err).&lt;span style="color:#447fcf">Errorln&lt;/span>(&lt;span style="color:#ed9d13">&amp;#34;remove chaosblade finalizer failed at destroyed phase&amp;#34;&lt;/span>)
}
&lt;span style="color:#6ab825;font-weight:bold">return&lt;/span> forget, &lt;span style="color:#6ab825;font-weight:bold">nil&lt;/span>
}
&lt;span style="color:#6ab825;font-weight:bold">if&lt;/span> cb.Status.Phase == v1alpha1.ClusterPhaseDestroying || cb.&lt;span style="color:#447fcf">GetDeletionTimestamp&lt;/span>() != &lt;span style="color:#6ab825;font-weight:bold">nil&lt;/span> {
err := r.&lt;span style="color:#447fcf">finalizeChaosBlade&lt;/span>(reqLogger, cb)
&lt;span style="color:#6ab825;font-weight:bold">if&lt;/span> err != &lt;span style="color:#6ab825;font-weight:bold">nil&lt;/span> {
reqLogger.&lt;span style="color:#447fcf">WithError&lt;/span>(err).&lt;span style="color:#447fcf">Errorln&lt;/span>(&lt;span style="color:#ed9d13">&amp;#34;finalize chaosblade failed at destroying phase&amp;#34;&lt;/span>)
}
&lt;span style="color:#6ab825;font-weight:bold">return&lt;/span> forget, &lt;span style="color:#6ab825;font-weight:bold">nil&lt;/span>
}
...
&lt;span style="color:#6ab825;font-weight:bold">return&lt;/span> forget, &lt;span style="color:#6ab825;font-weight:bold">nil&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果 &lt;code>Phase&lt;/code> 状态为 &lt;code>Destroyed&lt;/code>，则从 Finalizers 中移除 &lt;code>finalizer.chaosblade.io&lt;/code>，之后正常删除 CR。&lt;/p>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>在实际工作中，像 Finalizers 这样的东西太多了，很多平时挂在嘴边的东西，深究起来我们可能对其并不了解，甚至原本的理解就是错误的。在今后的文章中，除了各种实践干货，笔者还会将更多的精力投注到基本原理、底层实现、源码剖析中，更聚焦于技术本身，在不重复造轮子的基础上，学习和了解更多产品背后的代码设计和实现原理。最后在分享一句&lt;strong>弗兰西斯·培根&lt;/strong>的话：&lt;/p>
&lt;p>&lt;strong>“人生如同道路。最近的捷径通常是最坏的路。”&lt;/strong>&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#finalizers">使用 CustomResourceDefinition 扩展 Kubernetes API - kubernetes.io&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>