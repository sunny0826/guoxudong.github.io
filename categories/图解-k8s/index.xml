<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Guo Xudong&#39;s Blog·郭旭东的博客 – 图解 k8s</title>
    <link>https://guoxudong.io/categories/%E5%9B%BE%E8%A7%A3-k8s/</link>
    <description>Recent content in 图解 k8s on Guo Xudong&#39;s Blog·郭旭东的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Mon, 12 Oct 2020 15:21:14 +0800</lastBuildDate>
    
	  <atom:link href="https://guoxudong.io/categories/%E5%9B%BE%E8%A7%A3-k8s/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Post: 图解 K8S 源码 - Informer 篇</title>
      <link>https://guoxudong.io/post/diagrams-k8s-src-informer/</link>
      <pubDate>Mon, 12 Oct 2020 15:21:14 +0800</pubDate>
      
      <guid>https://guoxudong.io/post/diagrams-k8s-src-informer/</guid>
      <description>
        
        
        &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;众所周知，在 Kubernetes 中各组件是通过 HTTP 协议进行通信的，而组件间的通信也并没有依赖任何中间件，那么如何保证消息的实时性、可靠性、顺序性呢？&lt;strong&gt;Informer 机制&lt;/strong&gt;很好的解决了这个问题。Kubernetes 中各组件与 API Server 的通信都是通过 client-go 的 informer 机制来保证和完成的。&lt;/p&gt;
&lt;h2 id=&#34;控制器模式&#34;&gt;控制器模式&lt;/h2&gt;
&lt;p&gt;控制器模式最核心的就是控制循环的概念。而 Informer 机制，也就是控制循环中负责观察系统的传感器（Sensor）主要由 Reflector、Informer、Indexer 三个组件构成。其与各种资源的 Controller 相配合，就可以完成完整的控制循环，不断的使系统向终态趋近 &lt;code&gt;status&lt;/code&gt; -&amp;gt; &lt;code&gt;spec&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva2.sinaimg.cn/large/ad5fbf65ly1gjme5nhuykj20mr0fmn6j.jpg&#34; alt=&#34;informer 机制&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;informer&#34;&gt;Informer&lt;/h3&gt;
&lt;p&gt;所谓 informer，其实就是一个带有本地缓存和索引机制的，可以注册 EventHandler 的 client，目的是为了减轻频繁通信 API Server 的压力而抽取出来的一层 cache，客户端对 API Server 数据的&lt;strong&gt;读取&lt;/strong&gt;和&lt;strong&gt;监测&lt;/strong&gt;操作都通过本地的 informer 来进行。&lt;/p&gt;
&lt;p&gt;每一个 Kubernetes 资源上都实现了 informer 机制，每一个 informer 上都会实现 &lt;code&gt;Informer()&lt;/code&gt; 和 &lt;code&gt;Lister()&lt;/code&gt; 方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// client-go/informers/core/v1/pod.go
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;type&lt;/span&gt; PodInformer &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;interface&lt;/span&gt; {
  &lt;span style=&#34;color:#447fcf&#34;&gt;Informer&lt;/span&gt;() cache.SharedIndexInformer
  &lt;span style=&#34;color:#447fcf&#34;&gt;Lister&lt;/span&gt;() v1.PodLister
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;定义不同资源的 Informer，允许监控不同资源事件。同时为了避免同一资源的 Informer 被实例化多次，而每个 Informer 都会使用一个 Reflector，这样会运行过多相同的 ListAndWatch，从而加重 API Server 的压力，Informer 还提供了共享机制，多个 Informer 可以共享一个 Reflector，从而达到节约资源的目的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// client-go/informers/factory.go
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;type&lt;/span&gt; sharedInformerFactory &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
  client           kubernetes.Interface
  namespace        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt;
  tweakListOptions internalinterfaces.TweakListOptionsFunc
  lock             sync.Mutex
  defaultResync    time.Duration
  customResync     &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;map&lt;/span&gt;[reflect.Type]time.Duration

  informers &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;map&lt;/span&gt;[reflect.Type]cache.SharedIndexInformer
  &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// startedInformers is used for tracking which informers have been started.
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// This allows Start() to be called multiple times safely.
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;  startedInformers &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;map&lt;/span&gt;[reflect.Type]&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;bool&lt;/span&gt;
}
...
&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// InternalInformerFor returns the SharedIndexInformer for obj using an internal client.
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;func&lt;/span&gt; (f *sharedInformerFactory) &lt;span style=&#34;color:#447fcf&#34;&gt;InformerFor&lt;/span&gt;(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer {
  f.lock.&lt;span style=&#34;color:#447fcf&#34;&gt;Lock&lt;/span&gt;()
  &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;defer&lt;/span&gt; f.lock.&lt;span style=&#34;color:#447fcf&#34;&gt;Unlock&lt;/span&gt;()

  informerType := reflect.&lt;span style=&#34;color:#447fcf&#34;&gt;TypeOf&lt;/span&gt;(obj)
  informer, exists := f.informers[informerType]
  &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; exists {
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; informer
  }

  resyncPeriod, exists := f.customResync[informerType]
  &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; !exists {
    resyncPeriod = f.defaultResync
  }

  informer = &lt;span style=&#34;color:#447fcf&#34;&gt;newFunc&lt;/span&gt;(f.client, resyncPeriod)
  f.informers[informerType] = informer

  &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; informer
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用 map 数据结构实现共享 Informer 机制，在 &lt;code&gt;InformerFor()&lt;/code&gt; 函数添加了不同资源的 Informer，在添加过程中如果已经存在同类型的 Informer，则返回当前 Informer，不再继续添加。如下就是 &lt;code&gt;deployment&lt;/code&gt; 的 &lt;code&gt;Informer()&lt;/code&gt; 方法，其中就调用了 &lt;code&gt;InformerFor()&lt;/code&gt; 函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// client-go/informers/apps/v1beta1/deployment.go
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;func&lt;/span&gt; (f *deploymentInformer) &lt;span style=&#34;color:#447fcf&#34;&gt;Informer&lt;/span&gt;() cache.SharedIndexInformer {
  &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; f.factory.&lt;span style=&#34;color:#447fcf&#34;&gt;InformerFor&lt;/span&gt;(&amp;amp;appsv1beta1.Deployment{}, f.defaultInformer)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;reflector&#34;&gt;Reflector&lt;/h3&gt;
&lt;p&gt;Reflector 用于监测制定 Kubernetes 资源，当资源发生变化时，触发相应的事件，如：Added（资源添加）事件、Update（资源更新）事件、Delete（资源删除）事件，并将事件及资源名称添加到 DeltaFIFO 中。&lt;/p&gt;
&lt;h4 id=&#34;listandwatch&#34;&gt;ListAndWatch&lt;/h4&gt;
&lt;p&gt;在实例化 Reflector 时，必须传入 ListerWatcher 接口对象，其拥有 &lt;code&gt;List()&lt;/code&gt; 和 &lt;code&gt;Watch()&lt;/code&gt; 方法。Reflector 通过 &lt;code&gt;Run()&lt;/code&gt; 方法启动监控并处理事件。在程序第一次运行时，会执行 &lt;code&gt;List()&lt;/code&gt; 方法将所有的对象数据存入 DeltaFIFO 中，每次 Controller 重启，都会执行 &lt;code&gt;List()&lt;/code&gt; 方法；同时，Reflector 实例中还有 &lt;code&gt;resyncPeriod&lt;/code&gt; 参数，如果该参数不为 0，则会根据该参数值周期性的执行 &lt;code&gt;List()&lt;/code&gt; 操作，此时这些资源对象会被设置为 Sync 操作类型（不同于 Add、Update 等）。&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;Watch()&lt;/code&gt; 则会根据 Reflector 实例 &lt;code&gt;period&lt;/code&gt; 参数，周期性的监控资源对象是否有变更。如果发生变更，则通过 &lt;code&gt;r.watchHandler&lt;/code&gt; 处理变更事件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva4.sinaimg.cn/large/ad5fbf65ly1gjmkxmiboej20mr0uwh9f.jpg&#34; alt=&#34;Reflector&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;deltafifo&#34;&gt;DeltaFIFO&lt;/h4&gt;
&lt;p&gt;DeltaFIFO 顾名思义，Delta 是一个资源对象存储，可以保持操作类型（Add、Update、Delete、Sync等）；而 FIFO 则是一个先进先出的队列。其是一个生产者与消费者的队列，其中 Reflector 是生产者，消费者则调用 &lt;code&gt;Pop()&lt;/code&gt; 方法取出最早进入队列的对象数据。&lt;/p&gt;
&lt;h3 id=&#34;indexer&#34;&gt;Indexer&lt;/h3&gt;
&lt;p&gt;Indexer 是 client-go 用来存储资源对象并自带索引功能的本地存储，Reflector 从 DeltaFIFO 中将消费出来的资源对象存储至 Indexer。同时 Indexer 中的数据与 Etcd 中的数据保持完全一致。client-go 可以很方便的从本次存储中读取相应的资源对象数据，而无需每次都从远程 Etcd 集群中读取，从而降低了 API Server 和 Etcd 集群的压力。&lt;/p&gt;
&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;
&lt;p&gt;要了解 Kubernetes，Informer 是绕不过的内容，其在 Kubernetes 中非常重要。本文主要图解了 Informer 机制以及 Reflector，由于篇幅有限，DeltaFIFO，Indexer 等概念只做了简单介绍，这些内容会在后续的文章中进行详解，敬请期待。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;《Kubernetes 源码剖析 - 郑东旭著》&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Post: 图解 K8S 源码 - Deployment Controller 篇</title>
      <link>https://guoxudong.io/post/diagrams-k8s-src-deployment-controller/</link>
      <pubDate>Mon, 28 Sep 2020 15:00:38 +0800</pubDate>
      
      <guid>https://guoxudong.io/post/diagrams-k8s-src-deployment-controller/</guid>
      <description>
        
        
        &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;Kubernetes 最为云原生领域的绝对 leader，可以说是当下最著名开源项目之一，拥有着庞大的贡献者群体以及更庞大的用户群体。作为使用 Go 语言开发的明星项目，其源码也是非常有趣的。笔者在研究 Kubernetes 源码时，常常发现很多让人眼前一亮的设计和拍案叫绝的逻辑。但由于 Kubernetes 的代码量十分庞大，函数间的调用也十分复杂，在阅读源码时常常被绕的找不着北，正好手边有一本《图解算法》，于是就萌生了图解 Kubernetes 源码的想法。本文为本系列第一篇文章，尝试使用流程图来分析 Kubernetes Controller Manager 中 的 Deployment Controller 逻辑。&lt;/p&gt;
&lt;h2 id=&#34;deployment-controller&#34;&gt;Deployment Controller&lt;/h2&gt;
&lt;p&gt;Deployment Controller 是 Kube-Controller-Manager 中最常用的 Controller 之一管理 Deployment 资源。而 Deployment 的本质就是通过管理 ReplicaSet 和 Pod 在 Kubernetes 集群中部署 &lt;strong&gt;无状态&lt;/strong&gt; Workload。&lt;/p&gt;
&lt;h3 id=&#34;deploymentreplicaset-和-pod&#34;&gt;Deployment、ReplicaSet 和 Pod&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax4.sinaimg.cn/large/ad5fbf65gy1gj6twofn24j20es09s43a.jpg&#34; alt=&#34;deployment-controller&#34;&gt;&lt;/p&gt;
&lt;p&gt;Deployment 通过控制 ReplicaSet，ReplicaSet 再控制 Pod，最终由 Controller 驱动达到期望状态。在控制器模式下，每次操作对象都会触发一次事件，然后 controller 会进行一次 syncLoop 操作，controller 是通过 informer 监听事件以及进行 ListWatch 操作的。&lt;/p&gt;
&lt;p&gt;Deployment Controller 会监听 DeploymentInformer、ReplicaSetInformer、PodInformer 三种资源。这三种资源变化时，都会触发 syncLoop 也就是下面代码 &lt;code&gt;dc.Run()&lt;/code&gt; 中的 &lt;code&gt;dc.syncDeployment&lt;/code&gt; 操作，来进行状态更新逻辑。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;startDeploymentController&lt;/span&gt;(ctx ControllerContext) (http.Handler, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;bool&lt;/span&gt;, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;error&lt;/span&gt;) {
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; !ctx.AvailableResources[schema.GroupVersionResource{Group: &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;apps&amp;#34;&lt;/span&gt;, Version: &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;v1&amp;#34;&lt;/span&gt;, Resource: &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;deployments&amp;#34;&lt;/span&gt;}] {
      &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;false&lt;/span&gt;, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;nil&lt;/span&gt;
    }
    dc, err := deployment.&lt;span style=&#34;color:#447fcf&#34;&gt;NewDeploymentController&lt;/span&gt;(
      ctx.InformerFactory.&lt;span style=&#34;color:#447fcf&#34;&gt;Apps&lt;/span&gt;().&lt;span style=&#34;color:#447fcf&#34;&gt;V1&lt;/span&gt;().&lt;span style=&#34;color:#447fcf&#34;&gt;Deployments&lt;/span&gt;(),
      ctx.InformerFactory.&lt;span style=&#34;color:#447fcf&#34;&gt;Apps&lt;/span&gt;().&lt;span style=&#34;color:#447fcf&#34;&gt;V1&lt;/span&gt;().&lt;span style=&#34;color:#447fcf&#34;&gt;ReplicaSets&lt;/span&gt;(),
      ctx.InformerFactory.&lt;span style=&#34;color:#447fcf&#34;&gt;Core&lt;/span&gt;().&lt;span style=&#34;color:#447fcf&#34;&gt;V1&lt;/span&gt;().&lt;span style=&#34;color:#447fcf&#34;&gt;Pods&lt;/span&gt;(),
      ctx.ClientBuilder.&lt;span style=&#34;color:#447fcf&#34;&gt;ClientOrDie&lt;/span&gt;(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;deployment-controller&amp;#34;&lt;/span&gt;),
    )
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
      &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;true&lt;/span&gt;, fmt.&lt;span style=&#34;color:#447fcf&#34;&gt;Errorf&lt;/span&gt;(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;error creating Deployment controller: %v&amp;#34;&lt;/span&gt;, err)
    }
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;go&lt;/span&gt; dc.&lt;span style=&#34;color:#447fcf&#34;&gt;Run&lt;/span&gt;(&lt;span style=&#34;color:#24909d&#34;&gt;int&lt;/span&gt;(ctx.ComponentConfig.DeploymentController.ConcurrentDeploymentSyncs), ctx.Stop)
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;true&lt;/span&gt;, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;nil&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;deployment-controller-启动流程&#34;&gt;Deployment Controller 启动流程&lt;/h3&gt;
&lt;p&gt;那么先从启动逻辑开始，Kube-Controller-Manager 中所有的 Controller 的启动逻辑都差不多，都是在 &lt;code&gt;Run()&lt;/code&gt; 方法中完成初始化并启动，&lt;code&gt;NewControllerInitializers&lt;/code&gt; 会初始化所有 Controller，而 &lt;code&gt;startXXXXController()&lt;/code&gt; 则会启动对应的 Controller。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva3.sinaimg.cn/large/ad5fbf65gy1gj6rw439nrj20mh12o7wh.jpg&#34; alt=&#34;deployment-controller-启动流程&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;核心逻辑-synchandler&#34;&gt;核心逻辑 syncHandler&lt;/h3&gt;
&lt;p&gt;Deployment Controller 在初始化时指定了 &lt;code&gt;dc.syncHandler = dc.syncDeployment&lt;/code&gt;，所以核心逻辑就是围绕 &lt;code&gt;syncDeployment()&lt;/code&gt; 来展开的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax4.sinaimg.cn/large/ad5fbf65gy1gj6s4tfuynj20my1zq7wi.jpg&#34; alt=&#34;deployment-controller-核心逻辑&#34;&gt;&lt;/p&gt;
&lt;p&gt;从源码可以看出，删除、暂停、回滚、扩缩容、更新策略的优先级为 &lt;code&gt;delete &amp;gt; pause &amp;gt; rollback &amp;gt; scale &amp;gt; rollout&lt;/code&gt;。而最终都不是直接更新或修改对应资源，而是通过 &lt;code&gt;dc.client.AppsV1().Deployments().UpdateStatus()&lt;/code&gt; 更新 Deployment Status。&lt;/p&gt;
&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;
&lt;p&gt;以上就是 Deployment Controller 代码逻辑，通过流程图，希望能描述的更加清晰。因为是第一次尝试图解，可能有遗漏和不足，欢迎留言指正。图解 Kubernetes 源码将作为一个系列继续下去，后续会带来更多的源码图解。&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
