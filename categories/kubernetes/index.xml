<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Guo Xudong's Blog·郭旭东的博客 – Kubernetes</title><link>https://guoxudong.io/categories/kubernetes/</link><description>Recent content in Kubernetes on Guo Xudong's Blog·郭旭东的博客</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Tue, 22 Dec 2020 15:59:28 +0800</lastBuildDate><atom:link href="https://guoxudong.io/categories/kubernetes/index.xml" rel="self" type="application/rss+xml"/><item><title>Post: 使用 Helmfile 解放你的 Helm Chart</title><link>https://guoxudong.io/post/helmfile-quick-start/</link><pubDate>Tue, 22 Dec 2020 15:59:28 +0800</pubDate><guid>https://guoxudong.io/post/helmfile-quick-start/</guid><description>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>Helm 作为 Kubernetes 的包管理工具和 CNCF 毕业项目，在业界被广泛使用。但在实际使用场景中的一些需求 helm 并不能很好的满足，需要进行一些修改和适配，如同时部署多个 chart、不同部署环境的区分以及 chart 的版本控制。&lt;code>Helmfile&lt;/code> 就是一个能够很好解决这些问题的小工具。&lt;/p>
&lt;h2 id="基础介绍">基础介绍&lt;/h2>
&lt;p>Helmfile 通过 &lt;code>helmfile.yaml&lt;/code> 文件帮助用户管理和维护众多 helm chart，其最主要作用是：&lt;/p>
&lt;ul>
&lt;li>集成在 CI/CD 系统中，提高部署的可观测性和可重复性，区分环境，免去各种 &lt;code>--set&lt;/code> 造成的困扰。&lt;/li>
&lt;li>方便对 helm chart 进行版本控制，如指定版本范围、锁定版本等。&lt;/li>
&lt;li>定期同步，避免环境中出现不符合预期的配置。&lt;/li>
&lt;/ul>
&lt;h3 id="安装">安装&lt;/h3>
&lt;p>helmfile 提供了多种安装方式，除了直接在 &lt;a href="https://github.com/roboll/helmfile/releases">release 页面&lt;/a>下载，还可以通过如下方式安装：&lt;/p>
&lt;ul>
&lt;li>macOS (使用 homebrew): &lt;code>brew install helmfile&lt;/code>&lt;/li>
&lt;li>Windows (使用 scoop): &lt;code>scoop install helmfile&lt;/code>&lt;/li>
&lt;li>Archlinux: &lt;code>pacman -S helmfile&lt;/code>&lt;/li>
&lt;li>openSUSE: &lt;code>zypper in helmfile&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>同时还支持作为容器运行，可以非常方便的集成到 CI/CD 系统中：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#999;font-style:italic"># helm 2&lt;/span>
$ docker run --rm --net=host -v &lt;span style="color:#ed9d13">&amp;#34;&lt;/span>&lt;span style="color:#ed9d13">${&lt;/span>&lt;span style="color:#40ffff">HOME&lt;/span>&lt;span style="color:#ed9d13">}&lt;/span>&lt;span style="color:#ed9d13">/.kube:/root/.kube&amp;#34;&lt;/span> -v &lt;span style="color:#ed9d13">&amp;#34;&lt;/span>&lt;span style="color:#ed9d13">${&lt;/span>&lt;span style="color:#40ffff">HOME&lt;/span>&lt;span style="color:#ed9d13">}&lt;/span>&lt;span style="color:#ed9d13">/.helm:/root/.helm&amp;#34;&lt;/span> -v &lt;span style="color:#ed9d13">&amp;#34;&lt;/span>&lt;span style="color:#ed9d13">${&lt;/span>&lt;span style="color:#40ffff">PWD&lt;/span>&lt;span style="color:#ed9d13">}&lt;/span>&lt;span style="color:#ed9d13">:/wd&amp;#34;&lt;/span> --workdir /wd quay.io/roboll/helmfile:v0.135.0 helmfile sync
&lt;span style="color:#999;font-style:italic"># helm 3&lt;/span>
$ docker run --rm --net=host -v &lt;span style="color:#ed9d13">&amp;#34;&lt;/span>&lt;span style="color:#ed9d13">${&lt;/span>&lt;span style="color:#40ffff">HOME&lt;/span>&lt;span style="color:#ed9d13">}&lt;/span>&lt;span style="color:#ed9d13">/.kube:/root/.kube&amp;#34;&lt;/span> -v &lt;span style="color:#ed9d13">&amp;#34;&lt;/span>&lt;span style="color:#ed9d13">${&lt;/span>&lt;span style="color:#40ffff">HOME&lt;/span>&lt;span style="color:#ed9d13">}&lt;/span>&lt;span style="color:#ed9d13">/.config/helm:/root/.config/helm&amp;#34;&lt;/span> -v &lt;span style="color:#ed9d13">&amp;#34;&lt;/span>&lt;span style="color:#ed9d13">${&lt;/span>&lt;span style="color:#40ffff">PWD&lt;/span>&lt;span style="color:#ed9d13">}&lt;/span>&lt;span style="color:#ed9d13">:/wd&amp;#34;&lt;/span> --workdir /wd quay.io/roboll/helmfile:helm3-v0.135.0 helmfile sync
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="其他依赖">其他依赖&lt;/h3>
&lt;p>除了安装 helmfile 以外，还需要安装 &lt;code>helm&lt;/code>、&lt;code>kubectl&lt;/code> 以及 helm 插件 &lt;a href="https://github.com/databus23/helm-diff">&lt;code>helm-diff&lt;/code>&lt;/a>。&lt;/p>
&lt;p>helm-diff 安装方式：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ helm plugin install https://github.com/databus23/helm-diff
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="helmfileyaml">helmfile.yaml&lt;/h3>
&lt;p>&lt;code>helmfile.yaml&lt;/code> 是 helmfile 的核心文件，其用来声明所有的配置。下面会简要介绍一下，详细内容见&lt;a href="https://github.com/roboll/helmfile#configuration">官方文档&lt;/a>。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#999;font-style:italic"># 声明 repo 配置&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">repositories&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>&amp;lt;repo-name&amp;gt;&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># url: repo url&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># 可以设置基础配置 或 tls 认证&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># certFile: certificate 文件&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># keyFile: key 文件&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># username: 用户名&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># password: 密码&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># helm 二进制文件的路径&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">helmBinary&lt;/span>:&lt;span style="color:#666"> &lt;/span>path/to/helm3&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># helm 的一些默认设置，这些配置与 `helm SUBCOMMAND` 相同，可以通过这个配置声明一些，默认的配置&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">helmDefaults&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">tillerNamespace&lt;/span>:&lt;span style="color:#666"> &lt;/span>tiller-namespace &lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic">#dedicated default key for tiller-namespace&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">tillerless&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">false&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic">#dedicated default key for tillerless&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">kubeContext&lt;/span>:&lt;span style="color:#666"> &lt;/span>kube-context &lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic">#dedicated default key for kube-context (--kube-context)&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">cleanupOnFail&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">false&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic">#dedicated default key for helm flag --cleanup-on-fail&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># additional and global args passed to helm (default &amp;#34;&amp;#34;)&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">args&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#ed9d13">&amp;#34;--set k=v&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># verify the chart before upgrading (only works with packaged charts not directories) (default false)&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">verify&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">true&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># wait for k8s resources via --wait. (default false)&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">wait&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">true&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># time in seconds to wait for any individual Kubernetes operation (like Jobs for hooks, and waits on pod/pvc/svc/deployment readiness) (default 300)&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">timeout&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#3677a9">600&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># performs pods restart for the resource if applicable (default false)&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">recreatePods&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">true&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># forces resource update through delete/recreate if needed (default false)&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">force&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">false&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># when using helm 3.2+, automatically create release namespaces if they do not exist (default true)&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">createNamespace&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">true&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>...&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># 为 helmfile 中所有的 release 设置相同的 label，可用于为所有 release 标记相同的版本&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">commonLabels&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">hello&lt;/span>:&lt;span style="color:#666"> &lt;/span>world&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># 设置 release 配置（支持多 release）&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">releases&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># 远程 chart 示例（chart 已经上传到 remote 仓库）&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>vault &lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># name of this release&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">namespace&lt;/span>:&lt;span style="color:#666"> &lt;/span>vault &lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># target namespace&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">createNamespace&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">true&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># helm 3.2+ automatically create release namespace (default true)&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">labels&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># Arbitrary key value pairs for filtering releases&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">foo&lt;/span>:&lt;span style="color:#666"> &lt;/span>bar&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">chart&lt;/span>:&lt;span style="color:#666"> &lt;/span>roboll/vault-secret-manager &lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># the chart being installed to create this release, referenced by `repository/chart` syntax&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">version&lt;/span>:&lt;span style="color:#666"> &lt;/span>~1.24.1 &lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># the semver of the chart. range constraint is supported&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">condition&lt;/span>:&lt;span style="color:#666"> &lt;/span>vault.enabled &lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># The values lookup key for filtering releases. Corresponds to the boolean value of `vault.enabled`, where `vault` is an arbitrary value&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">missingFileHandler&lt;/span>:&lt;span style="color:#666"> &lt;/span>Warn&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># set to either &amp;#34;Error&amp;#34; or &amp;#34;Warn&amp;#34;. &amp;#34;Error&amp;#34; instructs helmfile to fail when unable to find a values or secrets file. When &amp;#34;Warn&amp;#34;, it prints the file and continues.&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># Values files used for rendering the chart&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">values&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># Value files passed via --values&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- vault.yaml&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># Inline values, passed via a temporary values file and --values, so that it doesn&amp;#39;t suffer from type issues like --set&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">address&lt;/span>:&lt;span style="color:#666"> &lt;/span>https://vault.example.com&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># Go template available in inline values and values files.&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">image&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># The end result is more or less YAML. So do `quote` to prevent number-like strings from accidentally parsed into numbers!&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># See https://github.com/roboll/helmfile/issues/608&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">tag&lt;/span>:&lt;span style="color:#666"> &lt;/span>{{&lt;span style="color:#666"> &lt;/span>requiredEnv &amp;#34;IMAGE_TAG&amp;#34; | quote }}&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># Otherwise:&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># tag: &amp;#34;{{ requiredEnv &amp;#34;IMAGE_TAG&amp;#34; }}&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># tag: !!string {{ requiredEnv &amp;#34;IMAGE_TAG&amp;#34; }}&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">db&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">username&lt;/span>:&lt;span style="color:#666"> &lt;/span>{{&lt;span style="color:#666"> &lt;/span>requiredEnv &amp;#34;DB_USERNAME&amp;#34; }}&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># value taken from environment variable. Quotes are necessary. Will throw an error if the environment variable is not set. $DB_PASSWORD needs to be set in the calling environment ex: export DB_PASSWORD=&amp;#39;password1&amp;#39;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">password&lt;/span>:&lt;span style="color:#666"> &lt;/span>{{&lt;span style="color:#666"> &lt;/span>requiredEnv &amp;#34;DB_PASSWORD&amp;#34; }}&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">proxy&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># Interpolate environment variable with a fixed string&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">domain&lt;/span>:&lt;span style="color:#666"> &lt;/span>{{&lt;span style="color:#666"> &lt;/span>requiredEnv &amp;#34;PLATFORM_ID&amp;#34; }}.my-domain.com&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">scheme&lt;/span>:&lt;span style="color:#666"> &lt;/span>{{&lt;span style="color:#666"> &lt;/span>env &amp;#34;SCHEME&amp;#34; | default &amp;#34;https&amp;#34; }}&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># Use `values` whenever possible!&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># `set` translates to helm&amp;#39;s `--set key=val`, that is known to suffer from type issues like https://github.com/roboll/helmfile/issues/608&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">set&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># single value loaded from a local file, translates to --set-file foo.config=path/to/file&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>foo.config&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">file&lt;/span>:&lt;span style="color:#666"> &lt;/span>path/to/file&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># set a single array value in an array, translates to --set bar[0]={1,2}&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>bar[0]&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">values&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#3677a9">1&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#3677a9">2&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># set a templated value&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>namespace&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">value&lt;/span>:&lt;span style="color:#666"> &lt;/span>{{&lt;span style="color:#666"> &lt;/span>.Namespace }}&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># will attempt to decrypt it using helm-secrets plugin&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># 本地 chart 示例（chart 保存在本地）&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>grafana &lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># name of this release&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">namespace&lt;/span>:&lt;span style="color:#666"> &lt;/span>another &lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># target namespace&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">chart&lt;/span>:&lt;span style="color:#666"> &lt;/span>../my-charts/grafana &lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># the chart being installed to create this release, referenced by relative path to local helmfile&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">values&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#ed9d13">&amp;#34;../../my-values/grafana/values.yaml&amp;#34;&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># Values file (relative path to manifest)&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- ./values/{{ requiredEnv &amp;#34;PLATFORM_ENV&amp;#34; }}/config.yaml&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># Values file taken from path with environment variable. $PLATFORM_ENV must be set in the calling environment.&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">wait&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">true&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># 可以嵌套其他的 helmfiles，支持从本地和远程拉取 helmfile&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">helmfiles&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">path&lt;/span>:&lt;span style="color:#666"> &lt;/span>path/to/subhelmfile.yaml&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># label 选择器可以过滤需要覆盖的 release&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">selectors&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- name=prometheus&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># 覆盖 value&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">values&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># 使用文件覆盖&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- additional.values.yaml&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># 覆盖单独的 key&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">key1&lt;/span>:&lt;span style="color:#666"> &lt;/span>val1&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>- &lt;span style="color:#999;font-style:italic"># 远程拉取配置&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">path&lt;/span>:&lt;span style="color:#666"> &lt;/span>git::https://github.com/cloudposse/helmfiles.git@releases/kiam.yaml?ref=0.40.0&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># 如果指向不存在路径，则打印告警错误&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">missingFileHandler&lt;/span>:&lt;span style="color:#666"> &lt;/span>Error&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># 多环境管理&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">environments&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># 当没有设置 `--environment NAME` 时，使用 default &lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">default&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">values&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># 内容可以是文件路径或者 key:value&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- environments/default/values.yaml&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">myChartVer&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#3677a9">1.0.0&lt;/span>-dev&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># &amp;#34;production&amp;#34; 环境，当设置了 `helmfile --environment production sync` 时&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">production&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">values&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- environment/production/values.yaml&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">myChartVer&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#3677a9">1.0.0&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># disable vault release processing&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">vault&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">enabled&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">false&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic">## `secrets.yaml` is decrypted by `helm-secrets` and available via `{{ .Environment.Values.KEY }}`&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">secrets&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- environment/production/secrets.yaml&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># 当占不到 `environments.NAME.values` 时，可以设置为 &amp;#34;Error&amp;#34;, &amp;#34;Warn&amp;#34;, &amp;#34;Info&amp;#34;, &amp;#34;Debug&amp;#34;，默认是 &amp;#34;Error&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">missingFileHandler&lt;/span>:&lt;span style="color:#666"> &lt;/span>Error&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># 分层管理，可以将所有文件合并，顺序为：environments.yaml &amp;lt; - defaults.yaml &amp;lt; - templates.yaml &amp;lt; - helmfile.yaml&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">bases&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>- environments.yaml&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>- defaults.yaml&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>- templates.yaml&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># API 功能&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">apiVersions&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>- example/v1&lt;span style="color:#666">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="apply">Apply&lt;/h3>
&lt;p>&lt;code>helmfile apply&lt;/code> 是 helmfile 中最常用命令，体验与 &lt;code>kubectl apply&lt;/code> 类似，根据 &lt;code>helmfile.yaml&lt;/code> 中声明的配置可以一键执行相应的动作，如：添加 repo、安装或更新 release 等。&lt;/p>
&lt;p>&lt;code>helmfile.yaml&lt;/code> 如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#6ab825;font-weight:bold">repositories&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>stable&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">url&lt;/span>:&lt;span style="color:#666"> &lt;/span>https://charts.helm.sh/stable&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">releases&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>prom-norbac-ubuntu&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">namespace&lt;/span>:&lt;span style="color:#666"> &lt;/span>prometheus&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">chart&lt;/span>:&lt;span style="color:#666"> &lt;/span>stable/prometheus&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">set&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>rbac.create&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">value&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">false&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行 &lt;code>helmfile apply&lt;/code> 之后，helmfile 会进行如下操作：&lt;/p>
&lt;ol>
&lt;li>添加 &lt;code>repositories&lt;/code> 中声明的 repo&lt;/li>
&lt;li>运行 &lt;code>helm diff&lt;/code> 进行对比&lt;/li>
&lt;li>根据 &lt;code>release&lt;/code>中声明的配置，安装或更新 chart&lt;/li>
&lt;/ol>
&lt;p>效果如下(由于输出内容过多，这里只节选了部分输出)：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">Adding repo stable https://charts.helm.sh/stable
&lt;span style="color:#ed9d13">&amp;#34;stable&amp;#34;&lt;/span> has been added to your repositories
Comparing &lt;span style="color:#40ffff">release&lt;/span>=prom-norbac-ubuntu, &lt;span style="color:#40ffff">chart&lt;/span>=stable/prometheus
...
prometheus, prom-norbac-ubuntu-prometheus-server, ServiceAccount (v1) has been added:
-
+ &lt;span style="color:#999;font-style:italic"># Source: prometheus/templates/rbac/server-serviceaccount.yaml&lt;/span>
+ apiVersion: v1
+ kind: ServiceAccount
+ metadata:
+ labels:
+ component: &lt;span style="color:#ed9d13">&amp;#34;server&amp;#34;&lt;/span>
+ app: prometheus
+ release: prom-norbac-ubuntu
+ chart: prometheus-11.12.1
+ heritage: Helm
+ name: prom-norbac-ubuntu-prometheus-server
+ namespace: prometheus
+ annotations:
+ {}
Upgrading &lt;span style="color:#40ffff">release&lt;/span>=prom-norbac-ubuntu, &lt;span style="color:#40ffff">chart&lt;/span>=stable/prometheus
Release &lt;span style="color:#ed9d13">&amp;#34;prom-norbac-ubuntu&amp;#34;&lt;/span> does not exist. Installing it now.
NAME: prom-norbac-ubuntu
LAST DEPLOYED: Wed Dec &lt;span style="color:#3677a9">23&lt;/span> 11:23:31 &lt;span style="color:#3677a9">2020&lt;/span>
NAMESPACE: prometheus
STATUS: deployed
REVISION: &lt;span style="color:#3677a9">1&lt;/span>
TEST SUITE: None
NOTES:
...
Listing releases matching ^prom-norbac-ubuntu$
prom-norbac-ubuntu prometheus &lt;span style="color:#3677a9">1&lt;/span> 2020-12-23 11:23:31.779328 +0800 CST deployed prometheus-11.12.1 2.20.1
UPDATED RELEASES:
NAME CHART VERSION
prom-norbac-ubuntu stable/prometheus 11.12.1
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="模板化">模板化&lt;/h3>
&lt;p>helmfile 和 helm templete 一样可以使用 &lt;a href="https://godoc.org/text/template">Go templates&lt;/a>，同时还有一个特殊的功能 &lt;code>requiredEnv&lt;/code>，该函数允许声明模板渲染所需的特定环境变量，如果环境变量未设置或为空，则渲染失败返回错误信息。&lt;/p>
&lt;h3 id="使用环境变量">使用环境变量&lt;/h3>
&lt;p>可以在 helmfile 中直接使用环境变量，使用方式如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#6ab825;font-weight:bold">repositories&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>your-private-git-repo-hosted-charts&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">url&lt;/span>:&lt;span style="color:#666"> &lt;/span>https://{{ requiredEnv &amp;#34;GITHUB_TOKEN&amp;#34;}}@raw.githubusercontent.com/kmzfs/helm-repo-in-github/master/&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">releases&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>{{&lt;span style="color:#666"> &lt;/span>requiredEnv &amp;#34;NAME&amp;#34; }}-vault&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">namespace&lt;/span>:&lt;span style="color:#666"> &lt;/span>{{&lt;span style="color:#666"> &lt;/span>requiredEnv &amp;#34;NAME&amp;#34; }}&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">chart&lt;/span>:&lt;span style="color:#666"> &lt;/span>roboll/vault-secret-manager&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">values&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">db&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">username&lt;/span>:&lt;span style="color:#666"> &lt;/span>{{&lt;span style="color:#666"> &lt;/span>requiredEnv &amp;#34;DB_USERNAME&amp;#34; }}&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">password&lt;/span>:&lt;span style="color:#666"> &lt;/span>{{&lt;span style="color:#666"> &lt;/span>requiredEnv &amp;#34;DB_PASSWORD&amp;#34; }}&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">set&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>proxy.domain&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">value&lt;/span>:&lt;span style="color:#666"> &lt;/span>{{&lt;span style="color:#666"> &lt;/span>requiredEnv &amp;#34;PLATFORM_ID&amp;#34; }}.my-domain.com&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>proxy.scheme&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">value&lt;/span>:&lt;span style="color:#666"> &lt;/span>{{&lt;span style="color:#666"> &lt;/span>env &amp;#34;SCHEME&amp;#34; | default &amp;#34;https&amp;#34; }}&lt;span style="color:#666">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="进阶实践">进阶实践&lt;/h2>
&lt;p>helm 还有一些进阶使用方式，如：版本控制、环境区分、hook、交互式操作、集成 kustomize 等。这里简单介绍几种，更多功能请看&lt;a href="https://github.com/roboll/helmfile">官方文档&lt;/a>。&lt;/p>
&lt;h3 id="版本控制">版本控制&lt;/h3>
&lt;p>helmfile 支持 &lt;a href="https://semver.org/lang/zh-CN/">Semver 2.0&lt;/a> 的版本号，可以锁定主版本，防止误升级导致的错误。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#6ab825;font-weight:bold">releases&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>vault &lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">namespace&lt;/span>:&lt;span style="color:#666"> &lt;/span>vault &lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">version&lt;/span>:&lt;span style="color:#666"> &lt;/span>~1.24.1 &lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># 限制版本 &amp;gt;=1.24.1 &amp;amp;&amp;amp; &amp;lt; 1.25.0&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同时还能通过 &lt;code>helmfile deps&lt;/code> 命令生成 lock 文件，在 CD 时，除非修改 lock 文件，否无法发布新版本。&lt;code>helmfile.lock&lt;/code> 内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#6ab825;font-weight:bold">version&lt;/span>:&lt;span style="color:#666"> &lt;/span>v0.135.0&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">dependencies&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>prometheus&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">repository&lt;/span>:&lt;span style="color:#666"> &lt;/span>https://charts.helm.sh/stable&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">version&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#3677a9">11.12.1&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">digest&lt;/span>:&lt;span style="color:#666"> &lt;/span>sha256:a5158f1361f2bbc4e73a80a22dd92b44538bdebeb2419658c36e31aa603b05fd&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">generated&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#ed9d13">&amp;#34;2020-12-23T16:26:57.42503+08:00&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当需要更新时，再次执行 &lt;code>helmfile deps&lt;/code> 即可。&lt;/p>
&lt;h3 id="区分环境">区分环境&lt;/h3>
&lt;p>这也是个使用率较高的功能，使用 &lt;code>environments&lt;/code> 配置·。如果不指定 &lt;code>--environment NAME&lt;/code> 参数，默认使用 &lt;code>default&lt;/code> 配置。&lt;/p>
&lt;p>这里假设有三个文件，&lt;code>helmfile.yaml&lt;/code>、&lt;code>production.yaml&lt;/code> 和 &lt;code>default.yaml&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#999;font-style:italic"># helmfile.yaml&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">environments&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">default&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">values&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- default.yaml&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">production&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">values&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- production.yaml &lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">releases&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>myapp-{{ .Values.releaseName }}&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># 根据环境名，可能是 `dev` 或 `prod`&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">values&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">url&lt;/span>:&lt;span style="color:#666"> &lt;/span>{&lt;span style="color:#666"> &lt;/span>.Values.domain }}&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># 根据环境名，可能是 `dev.example.com` 或 `prod.example.com`&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>{{&lt;span style="color:#666"> &lt;/span>if eq .Environment.Name &amp;#34;production&amp;#34; }}&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># 使用 Go template 的&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- values/production-specified-values.yaml&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>{{&lt;span style="color:#666"> &lt;/span>end }}&lt;span style="color:#666">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#999;font-style:italic"># production.yaml&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">domain&lt;/span>:&lt;span style="color:#666"> &lt;/span>prod.example.com&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">releaseName&lt;/span>:&lt;span style="color:#666"> &lt;/span>prod&lt;span style="color:#666">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#999;font-style:italic"># default.yaml&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">domain&lt;/span>:&lt;span style="color:#666"> &lt;/span>dev.example.com&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">releaseName&lt;/span>:&lt;span style="color:#666"> &lt;/span>dev&lt;span style="color:#666">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在执行 &lt;code>helmfile&lt;/code> 时，只需使用 &lt;code>--environment&lt;/code> 指定需要安装的环境：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ helmfile --environment production apply
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="hook">Hook&lt;/h3>
&lt;p>Helmfile hook 是一个每次发布的扩展点，它由以下部分组成：&lt;/p>
&lt;ul>
&lt;li>&lt;code>events&lt;/code>&lt;/li>
&lt;li>&lt;code>command&lt;/code>&lt;/li>
&lt;li>&lt;code>args&lt;/code>&lt;/li>
&lt;li>&lt;code>showlogs&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>helmfile 在运行时，会触发各种事件，一旦事件触发，相关的 &lt;code>hook&lt;/code> 就会被执行，目前支持的如下事件：&lt;/p>
&lt;ul>
&lt;li>&lt;code>prepare&lt;/code>&lt;/li>
&lt;li>&lt;code>presync&lt;/code>&lt;/li>
&lt;li>&lt;code>preuninstall&lt;/code>&lt;/li>
&lt;li>&lt;code>postuninstall&lt;/code>&lt;/li>
&lt;li>&lt;code>postsync&lt;/code>&lt;/li>
&lt;li>&lt;code>cleanup&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>下面这个示例，会打印事件触发时的的上下文信息。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#6ab825;font-weight:bold">environments&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">default&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">prod&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">releases&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>myapp&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">chart&lt;/span>:&lt;span style="color:#666"> &lt;/span>mychart&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># *snip*&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">hooks&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">events&lt;/span>:&lt;span style="color:#666"> &lt;/span>[&lt;span style="color:#ed9d13">&amp;#34;prepare&amp;#34;&lt;/span>,&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#ed9d13">&amp;#34;cleanup&amp;#34;&lt;/span>]&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">showlogs&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">true&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">command&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#ed9d13">&amp;#34;echo&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">args&lt;/span>:&lt;span style="color:#666"> &lt;/span>[&lt;span style="color:#ed9d13">&amp;#34;{{`{{.Environment.Name}}`}}&amp;#34;&lt;/span>,&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#ed9d13">&amp;#34;{{`{{.Release.Name}}`}}&amp;#34;&lt;/span>,&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#ed9d13">&amp;#34;{{`{{.HelmfileCommand}}`}}\
&lt;/span>&lt;span style="color:#ed9d13">&amp;#34;&lt;/span>]&lt;span style="color:#666">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行命令，可以看到 command 执行成功：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ helmfile -e prod sync
helmfile.yaml: &lt;span style="color:#40ffff">basePath&lt;/span>=.
hook[prepare] logs | prod myapp sync
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这也是个十分好用的功能，可以为不同的事件配置不同的 hook，这样在 CD 出现问题时，通过 hook 可以第一时间收到通知，并快速定位问题。&lt;/p>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>Helmfile 是一个很不错 Helm 生态工具，很大程度上弥补了 Helm 的不足。提高部署的可观测性和可重复性，提高了效率，最终实现 Release AS Code。&lt;/p></description></item><item><title>Post: K3d vs Kind 谁更适合本地研发</title><link>https://guoxudong.io/post/k3d-vs-kind/</link><pubDate>Wed, 18 Nov 2020 09:44:37 +0800</pubDate><guid>https://guoxudong.io/post/k3d-vs-kind/</guid><description>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>随着 Kubernetes 及其周边生态的发展壮大，新项目层出不穷，越来越多的开发者加入到了开发云原生应用的行列。随之而来的，就是 Kubernetes 极高的复杂度和研发人员想要快速开发云原生应用之间的矛盾。为了解决这个矛盾，同时也为了降低学习 Kubernetes 的门槛，社区出现了各种各样的解决方案。如 minikube 用于生成一个单节点的 k8s VM，而 katacoda 则是在 web 端提供交互式的 k8s 操作教程。&lt;/p>
&lt;p>在这些方案中，最有意思的一类方案是使用 docker 运行整个 k8s 集群，以极高的启动速度、极低的使用成本以及简单的操作深受广大开发者欢迎，并广泛应用于各种云原生应用开发和 e2e 测试中。其中最具代表性的就是 &lt;a href="https://kind.sigs.k8s.io/">Kubernetes SIGs 项目 Kind&lt;/a> 和 &lt;a href="https://k3d.io/">Rancher Lab 开源的 k3d&lt;/a>。在这篇文章中，我们就来探究一下这两个项目在本地开发侧的优缺点，站在一个开发者的的角度看看使用哪个项目更能提升我们的效率。&lt;/p>
&lt;h2 id="kind">Kind&lt;/h2>
&lt;p>&lt;img src="https://tvax3.sinaimg.cn/wap360/ad5fbf65gy1gkt56jeqr7j20rd0gimz7.jpg" alt="">&lt;/p>
&lt;p>Kind 顾名思义 Kubernetes in docker，是一个使用 docker 容器在本地运行 Kubernetes 集群的工具。其本身就是为了测试 Kubernetes 而设计，所以天生就和 CI 紧密关联，广泛应用于各种云原生项目的 CI 中，同时因为其可以快速拉起集群和操作简单，深受开发者喜爱，可谓是“有 Kind 不思 Minikube”。&lt;/p>
&lt;p>Kind 使用 kubeadm 进行集群的创建，内部使用 containerd 运行组件容器，可以通过指定配置文件 &lt;code>config.yaml&lt;/code> 来拉起相应配置的集群，支持多节点集群，同时也可以把本地的镜像加载到集群中，实现测试镜像无需上传镜像仓库的功能。并且之前国内拉取不到镜像的问题已经解决，直接在 dockerhub 拉取 &lt;code>kindest/node&lt;/code> 镜像，镜像中均已包含创建 Kubernetes 集群所需的全部资源，无需再额外下载。&lt;/p>
&lt;h2 id="k3d">K3d&lt;/h2>
&lt;p>&lt;img src="https://tvax2.sinaimg.cn/wap360/ad5fbf65gy1gkt5pu3ifhj21s00ocaef.jpg" alt="">&lt;/p>
&lt;p>与 Kind 类似，K3d 是使用 docker 容器在本地运行 k3s 集群，k3s 是由 Rancher Lab 开源的轻量级 Kubernetes。k3d 完美继承了 k3s 的简单、快速和占用资源少的优势，镜像大小只有 100 多 M，启动速度快，支持多节点集群。虽然 k3s 对 Kubernetes 进行了轻量化的裁剪，但是提供了完整了功能，像 Istio 这样复杂的云原生应用都可以在 k3s 上顺利运行。&lt;/p>
&lt;p>K3d 同时也有着自己的优势，除了启动速度快和占用资源少以外，在边缘计算和嵌入式领域也有着不俗的表现。因为 k3s 本身应用场景主要在边缘侧，所以支持的设备和架构很多，如：ARM64 和 ARMv7 处理器。很多老旧 PC 和树莓派这样的设备都可以拿来做成 k3s 集群，为本地研发测试燃尽最后的生命。&lt;/p>
&lt;h2 id="kind-vs-k3d">Kind vs K3d&lt;/h2>
&lt;p>下面就对 Kind 和 K3s 的进行一些简单的对比，对比数据均来自同一台 macbook pro，使用相同的资源进行。采用目前最新版本，版本如下：&lt;/p>
&lt;ul>
&lt;li>k3d v3.2.1&lt;/li>
&lt;li>kind v0.7.0&lt;/li>
&lt;/ul>
&lt;h3 id="工具安装">工具安装&lt;/h3>
&lt;p>K3d 和 Kind 均支持使用 &lt;code>brew&lt;/code> 安装，且均在安装时自动注入命令补全 &lt;code>completion&lt;/code> 脚本，安装好之后即可实现按 &lt;code>&amp;lt;TAB&amp;gt;&lt;/code> 自动补全命令，无需手动操作，体验极佳。&lt;/p>
&lt;h3 id="本地镜像注入">本地镜像注入&lt;/h3>
&lt;p>&lt;code>k3d image import&lt;/code> 和 &lt;code>kind load&lt;/code> 命令均可将本地镜像注入集群且均支持注入 docker 镜像或镜像文件。&lt;/p>
&lt;h3 id="base-镜像大小">base 镜像大小&lt;/h3>
&lt;p>本项 k3s 完胜，由于 k3s 本身就是轻量级的 Kubernetes，所以镜像极小，大小还没有 Kind base 镜像 &lt;code>kindest/node&lt;/code> 的零头大。&lt;/p>
&lt;p>&lt;img src="https://tva2.sinaimg.cn/large/ad5fbf65gy1gkta0t5u1mj20sk023q5p.jpg" alt="镜像大小比较">&lt;/p>
&lt;h3 id="启动速度">启动速度&lt;/h3>
&lt;p>这里的启动速度排除了镜像拉取的时间，两者的镜像均已拉取到本地，且启动的均为默认配置的集群。&lt;/p>
&lt;p>k3d 启动时间：&lt;/p>
&lt;p>&lt;img src="https://tvax2.sinaimg.cn/large/ad5fbf65gy1gkta5bjvuhj20gp03radf.jpg" alt="k3d 启动时间">&lt;/p>
&lt;p>kind 启动时间：&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/ad5fbf65gy1gkta5meujxj20hz06a79q.jpg" alt="kind 启动时间">&lt;/p>
&lt;p>可以看到还是 k3s 的启动速度要快于 Kind，因为 k3s 本身就是主打轻量级和快速启动，但 kind 的启动速度也很快，耗时均在本地用户的可接受范围内。&lt;/p>
&lt;h3 id="资源占用">资源占用&lt;/h3>
&lt;p>这里对比的两个集群均是默认配置，无运行任何其他组件和服务。同样 k3d 占用的资源更少，但总体都没有超出不可承受的范围。&lt;/p>
&lt;p>&lt;img src="https://tva4.sinaimg.cn/large/ad5fbf65gy1gktaadtyvqj20ul01rdik.jpg" alt="资源占用">&lt;/p>
&lt;h3 id="ingress">ingress&lt;/h3>
&lt;p>这项更偏向使用者的体验，k3s 自带了 traefik 作为 Ingress Controller 开箱即用，用户如果不想关心使用什么 ingress 可以无需关心，直接上手使用。而 Kind 则没有预装 Ingress Controller，如果需要使用则需要手动部署。&lt;/p>
&lt;h3 id="架构支持">架构支持&lt;/h3>
&lt;p>Kind 目前只支持 x86 的 CPU 架构，而 k3d 则支持 x86、ARM64 和 ARMv7，如果想在使用 M1 芯片的新 MacBook 或在有 ARM 架构 CPU 的 PC 上使用，暂时只能使用 k3d。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>通过对比可以看出 k3d 和 kind 的相似点很多，但两方的使用场景还是略有差别。Kind 更贴近原生 Kubernetes，适合用于开发测试 Kubernetes 原生组件、资源比较充沛的开发者；而 K3s 则更适合边缘计算场景应用开发、资源紧张、使用非 x86 CPU 架构设备的开发者。如果你只是想学习 Kubernetes 集群的操作、各种资源的使用、Kubernetes 相关项目的尝鲜，则这两个工具都是不错的选择。&lt;/p>
&lt;div class="alert alert-warning" role="alert">
&lt;h4 class="alert-heading">注意&lt;/h4>
两者都是为了方便测试 kubernetes 集群,切不可用于生产环境。
&lt;/div></description></item><item><title>Post: 熟悉又陌生的 k8s 字段：finalizers</title><link>https://guoxudong.io/post/k8s-gc-finalizers/</link><pubDate>Fri, 11 Sep 2020 08:47:51 +0800</pubDate><guid>https://guoxudong.io/post/k8s-gc-finalizers/</guid><description>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>经常操作 Kubernetes 集群的同学肯定对 &lt;code>finalizers&lt;/code> 字段不陌生，每当删除 namespace 或 pod 等一些 Kubernetes 资源时，有时资源状态会卡在 &lt;code>Terminating&lt;/code>，很长时间无法删除，甚至有时增加 &lt;code>--force&lt;/code> flag 之后还是无法正常删除。这时就需要 &lt;code>edit&lt;/code> 该资源，将 &lt;code>finalizers&lt;/code> 字段设置为 []，之后 Kubernetes 资源就正常删除了。&lt;/p>
&lt;p>这是一个比较常见的操作，但是当有人问 &lt;code>finalizers&lt;/code> 字段的作用是什么的时候，我是懵逼的，我甚至不知道这个熟悉又陌生的单词怎么读！那么这篇文章就来探索一下 &lt;code>finalizers&lt;/code> 这个字段到底是做什么的，在实践中应该怎么应用这个字段。（另外，这个单词读作 &lt;strong>[&amp;lsquo;faɪnəlaɪzər]&lt;/strong>）&lt;/p>
&lt;h2 id="finalizers">Finalizers&lt;/h2>
&lt;p>Finalizers 字段属于 Kubernetes GC 垃圾收集器，是一种删除拦截机制，能够让控制器实现异步的删除前（Pre-delete）回调。其存在于任何一个资源对象的 &lt;a href="https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/types.go#L246">Meta&lt;/a> 中，在 k8s 源码中声明为 &lt;code>[]string&lt;/code>，该 Slice 的内容为需要执行的拦截器名称。&lt;/p>
&lt;p>对带有 Finalizer 的对象的第一个删除请求会为其 &lt;code>metadata.deletionTimestamp&lt;/code> 设置一个值，但不会真的删除对象。一旦此值被设置，finalizers 列表中的值就&lt;strong>只能&lt;/strong>被移除。&lt;/p>
&lt;p>当 &lt;code>metadata.deletionTimestamp&lt;/code> 字段被设置时，负责监测该对象的各个控制器会通过&lt;strong>轮询&lt;/strong>对该对象的更新请求来执行它们所要处理的所有 Finalizer。 当所有 Finalizer 都被执行过，资源被删除。&lt;/p>
&lt;p>&lt;code>metadata.deletionGracePeriodSeconds&lt;/code> 的取值控制对更新的轮询周期。&lt;/p>
&lt;p>每个控制器要负责将其 Finalizer 从列表中去除。&lt;/p>
&lt;p>每执行完一个就从 &lt;code>finalizers&lt;/code> 中移除一个，直到 &lt;code>finalizers&lt;/code> 为空，之后其宿主资源才会被真正的删除。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#999;font-style:italic">// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
&lt;/span>&lt;span style="color:#999;font-style:italic">// field is set by the server when a graceful deletion is requested by the user, and is not
&lt;/span>&lt;span style="color:#999;font-style:italic">// directly settable by a client. The resource is expected to be deleted (no longer visible
&lt;/span>&lt;span style="color:#999;font-style:italic">// from resource lists, and not reachable by name) after the time in this field, once the
&lt;/span>&lt;span style="color:#999;font-style:italic">// finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
&lt;/span>&lt;span style="color:#999;font-style:italic">// Once the deletionTimestamp is set, this value may not be unset or be set further into the
&lt;/span>&lt;span style="color:#999;font-style:italic">// future, although it may be shortened or the resource may be deleted prior to this time.
&lt;/span>&lt;span style="color:#999;font-style:italic">// For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
&lt;/span>&lt;span style="color:#999;font-style:italic">// by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
&lt;/span>&lt;span style="color:#999;font-style:italic">// the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
&lt;/span>&lt;span style="color:#999;font-style:italic">// remove the pod from the API. In the presence of network partitions, this object may still
&lt;/span>&lt;span style="color:#999;font-style:italic">// exist after this timestamp, until an administrator or automated process can determine the
&lt;/span>&lt;span style="color:#999;font-style:italic">// resource is fully terminated.
&lt;/span>&lt;span style="color:#999;font-style:italic">// If not set, graceful deletion of the object has not been requested.
&lt;/span>&lt;span style="color:#999;font-style:italic">//
&lt;/span>&lt;span style="color:#999;font-style:italic">// Populated by the system when a graceful deletion is requested.
&lt;/span>&lt;span style="color:#999;font-style:italic">// Read-only.
&lt;/span>&lt;span style="color:#999;font-style:italic">// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
&lt;/span>&lt;span style="color:#999;font-style:italic">// +optional
&lt;/span>&lt;span style="color:#999;font-style:italic">&lt;/span>DeletionTimestamp *Time &lt;span style="color:#ed9d13">`json:&amp;#34;deletionTimestamp,omitempty&amp;#34; protobuf:&amp;#34;bytes,9,opt,name=deletionTimestamp&amp;#34;`&lt;/span>
&lt;span style="color:#999;font-style:italic">// Number of seconds allowed for this object to gracefully terminate before
&lt;/span>&lt;span style="color:#999;font-style:italic">// it will be removed from the system. Only set when deletionTimestamp is also set.
&lt;/span>&lt;span style="color:#999;font-style:italic">// May only be shortened.
&lt;/span>&lt;span style="color:#999;font-style:italic">// Read-only.
&lt;/span>&lt;span style="color:#999;font-style:italic">// +optional
&lt;/span>&lt;span style="color:#999;font-style:italic">&lt;/span>DeletionGracePeriodSeconds *&lt;span style="color:#6ab825;font-weight:bold">int64&lt;/span> &lt;span style="color:#ed9d13">`json:&amp;#34;deletionGracePeriodSeconds,omitempty&amp;#34; protobuf:&amp;#34;varint,10,opt,name=deletionGracePeriodSeconds&amp;#34;`&lt;/span>
&lt;span style="color:#999;font-style:italic">// Must be empty before the object is deleted from the registry. Each entry
&lt;/span>&lt;span style="color:#999;font-style:italic">// is an identifier for the responsible component that will remove the entry
&lt;/span>&lt;span style="color:#999;font-style:italic">// from the list. If the deletionTimestamp of the object is non-nil, entries
&lt;/span>&lt;span style="color:#999;font-style:italic">// in this list can only be removed.
&lt;/span>&lt;span style="color:#999;font-style:italic">// Finalizers may be processed and removed in any order. Order is NOT enforced
&lt;/span>&lt;span style="color:#999;font-style:italic">// because it introduces significant risk of stuck finalizers.
&lt;/span>&lt;span style="color:#999;font-style:italic">// finalizers is a shared field, any actor with permission can reorder it.
&lt;/span>&lt;span style="color:#999;font-style:italic">// If the finalizer list is processed in order, then this can lead to a situation
&lt;/span>&lt;span style="color:#999;font-style:italic">// in which the component responsible for the first finalizer in the list is
&lt;/span>&lt;span style="color:#999;font-style:italic">// waiting for a signal (field value, external system, or other) produced by a
&lt;/span>&lt;span style="color:#999;font-style:italic">// component responsible for a finalizer later in the list, resulting in a deadlock.
&lt;/span>&lt;span style="color:#999;font-style:italic">// Without enforced ordering finalizers are free to order amongst themselves and
&lt;/span>&lt;span style="color:#999;font-style:italic">// are not vulnerable to ordering changes in the list.
&lt;/span>&lt;span style="color:#999;font-style:italic">// +optional
&lt;/span>&lt;span style="color:#999;font-style:italic">// +patchStrategy=merge
&lt;/span>&lt;span style="color:#999;font-style:italic">&lt;/span>Finalizers []&lt;span style="color:#6ab825;font-weight:bold">string&lt;/span> &lt;span style="color:#ed9d13">`json:&amp;#34;finalizers,omitempty&amp;#34; patchStrategy:&amp;#34;merge&amp;#34; protobuf:&amp;#34;bytes,14,rep,name=finalizers&amp;#34;`&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="在-operator-中的应用">在 Operator 中的应用&lt;/h2>
&lt;p>知道了 Finalizers 是什么，那么当然也要知道怎么用 Finalizers 了。在实际开发 Operator 时，删除前（Pre-delete）回调是一个比较常见的功能，用于处理一些在资源删除前需要处理的逻辑，如：关联资源释放、释放资源通知、相关数据清理，甚至是阻止资源删除。一般 Finalizers 的处理也是会 &lt;code>Reconcile&lt;/code> 中实现的，下面就使用 &lt;a href="https://github.com/chaosblade-io/chaosblade-operator">chaosblade-operator&lt;/a> 中的源码，简单介绍一些 Finalizers 的使用方式。&lt;/p>
&lt;p>首先要了解的是 ChaosBlade-Operator 的工作原理：每个实验都会以 CR 的形式部署到 k8s 集群中，之后由 &lt;code>chaosblade-operator&lt;/code> 来操作以 DaemonSet 形式部署 &lt;code>chaosblade-tool&lt;/code> 对具体资源进行混沌实验。停止实验只需删除对应 CR 即可，在删除 CR 时，首先会执行一遍实验恢复逻辑，之后才会将 CR 删除。但如果恢复实验失败，则会将 CR 的 &lt;code>Phase&lt;/code> 设置为 &lt;code>Destroying&lt;/code>，而在 &lt;code>Reconcile&lt;/code> 中观测到 &lt;code>Phase&lt;/code> 状态为 &lt;code>Destroying&lt;/code> 或者 &lt;code>metadata.deletionTimestamp&lt;/code> 不为空时，就会不会移除 &lt;code>finalizers&lt;/code> 中的拦截器名称，阻止该 CR 被删除。&lt;/p>
&lt;p>这样设计的目的是为了在实验恢复失败后，让用户去主动查看实验恢复失败原因，如果是一些意外原因导致的实验恢复失败，及时去处理。在确认原因后，可使用 CLI 工具增加 &lt;code>--force-remove&lt;/code> 进去强制删除，项目维护者在 &lt;a href="https://github.com/chaosblade-io/chaosblade/issues/368">Issue#368&lt;/a> 中也就这个设计给出了解答。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#999;font-style:italic">// pkg/controller/chaosblade/controller.go 部分源码
&lt;/span>&lt;span style="color:#999;font-style:italic">&lt;/span>...
&lt;span style="color:#6ab825;font-weight:bold">const&lt;/span> chaosbladeFinalizer = &lt;span style="color:#ed9d13">&amp;#34;finalizer.chaosblade.io&amp;#34;&lt;/span>
...
&lt;span style="color:#6ab825;font-weight:bold">func&lt;/span> (r *ReconcileChaosBlade) &lt;span style="color:#447fcf">Reconcile&lt;/span>(request reconcile.Request) (reconcile.Result, &lt;span style="color:#6ab825;font-weight:bold">error&lt;/span>) {
reqLogger := logrus.&lt;span style="color:#447fcf">WithField&lt;/span>(&lt;span style="color:#ed9d13">&amp;#34;Request.Name&amp;#34;&lt;/span>, request.Name)
forget := reconcile.Result{}
&lt;span style="color:#999;font-style:italic">// Fetch the RC instance
&lt;/span>&lt;span style="color:#999;font-style:italic">&lt;/span> cb := &amp;amp;v1alpha1.ChaosBlade{}
err := r.client.&lt;span style="color:#447fcf">Get&lt;/span>(context.&lt;span style="color:#447fcf">TODO&lt;/span>(), request.NamespacedName, cb)
&lt;span style="color:#6ab825;font-weight:bold">if&lt;/span> err != &lt;span style="color:#6ab825;font-weight:bold">nil&lt;/span> {
&lt;span style="color:#6ab825;font-weight:bold">return&lt;/span> forget, &lt;span style="color:#6ab825;font-weight:bold">nil&lt;/span>
}
&lt;span style="color:#6ab825;font-weight:bold">if&lt;/span> &lt;span style="color:#24909d">len&lt;/span>(cb.Spec.Experiments) == &lt;span style="color:#3677a9">0&lt;/span> {
&lt;span style="color:#6ab825;font-weight:bold">return&lt;/span> forget, &lt;span style="color:#6ab825;font-weight:bold">nil&lt;/span>
}
&lt;span style="color:#999;font-style:italic">// Destroyed-&amp;gt;delete
&lt;/span>&lt;span style="color:#999;font-style:italic">&lt;/span> &lt;span style="color:#999;font-style:italic">// Remove the Finalizer if the CR object status is destroyed to delete it
&lt;/span>&lt;span style="color:#999;font-style:italic">&lt;/span> &lt;span style="color:#6ab825;font-weight:bold">if&lt;/span> cb.Status.Phase == v1alpha1.ClusterPhaseDestroyed {
cb.&lt;span style="color:#447fcf">SetFinalizers&lt;/span>(&lt;span style="color:#447fcf">remove&lt;/span>(cb.&lt;span style="color:#447fcf">GetFinalizers&lt;/span>(), chaosbladeFinalizer))
err := r.client.&lt;span style="color:#447fcf">Update&lt;/span>(context.&lt;span style="color:#447fcf">TODO&lt;/span>(), cb)
&lt;span style="color:#6ab825;font-weight:bold">if&lt;/span> err != &lt;span style="color:#6ab825;font-weight:bold">nil&lt;/span> {
reqLogger.&lt;span style="color:#447fcf">WithError&lt;/span>(err).&lt;span style="color:#447fcf">Errorln&lt;/span>(&lt;span style="color:#ed9d13">&amp;#34;remove chaosblade finalizer failed at destroyed phase&amp;#34;&lt;/span>)
}
&lt;span style="color:#6ab825;font-weight:bold">return&lt;/span> forget, &lt;span style="color:#6ab825;font-weight:bold">nil&lt;/span>
}
&lt;span style="color:#6ab825;font-weight:bold">if&lt;/span> cb.Status.Phase == v1alpha1.ClusterPhaseDestroying || cb.&lt;span style="color:#447fcf">GetDeletionTimestamp&lt;/span>() != &lt;span style="color:#6ab825;font-weight:bold">nil&lt;/span> {
err := r.&lt;span style="color:#447fcf">finalizeChaosBlade&lt;/span>(reqLogger, cb)
&lt;span style="color:#6ab825;font-weight:bold">if&lt;/span> err != &lt;span style="color:#6ab825;font-weight:bold">nil&lt;/span> {
reqLogger.&lt;span style="color:#447fcf">WithError&lt;/span>(err).&lt;span style="color:#447fcf">Errorln&lt;/span>(&lt;span style="color:#ed9d13">&amp;#34;finalize chaosblade failed at destroying phase&amp;#34;&lt;/span>)
}
&lt;span style="color:#6ab825;font-weight:bold">return&lt;/span> forget, &lt;span style="color:#6ab825;font-weight:bold">nil&lt;/span>
}
...
&lt;span style="color:#6ab825;font-weight:bold">return&lt;/span> forget, &lt;span style="color:#6ab825;font-weight:bold">nil&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果 &lt;code>Phase&lt;/code> 状态为 &lt;code>Destroyed&lt;/code>，则从 Finalizers 中移除 &lt;code>finalizer.chaosblade.io&lt;/code>，之后正常删除 CR。&lt;/p>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>在实际工作中，像 Finalizers 这样的东西太多了，很多平时挂在嘴边的东西，深究起来我们可能对其并不了解，甚至原本的理解就是错误的。在今后的文章中，除了各种实践干货，笔者还会将更多的精力投注到基本原理、底层实现、源码剖析中，更聚焦于技术本身，在不重复造轮子的基础上，学习和了解更多产品背后的代码设计和实现原理。最后在分享一句&lt;strong>弗兰西斯·培根&lt;/strong>的话：&lt;/p>
&lt;p>&lt;strong>“人生如同道路。最近的捷径通常是最坏的路。”&lt;/strong>&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#finalizers">使用 CustomResourceDefinition 扩展 Kubernetes API - kubernetes.io&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Post: 基于 Flagger 和 Nginx-Ingress 实现金丝雀发布</title><link>https://guoxudong.io/post/flagger-nginx-ingress/</link><pubDate>Thu, 02 Jul 2020 13:51:14 +0800</pubDate><guid>https://guoxudong.io/post/flagger-nginx-ingress/</guid><description>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>很久之前我写过一篇介绍使用 Nginx-Ingress 实现蓝绿部署和金丝雀发布的文章，但那篇文章只是介绍了 nginx-ingress 具备这些能力，真正应用还要很多额外的配置和操作，况且现在能实现这些功能的并不只有 nginx-ingress，Service Mesh 工具如：Istio，App Mesh，Linkerd；Ingress Controller 如：Contour，Gloo，NGINX 都能实现，而我们需要的更多是进行金丝雀发布之后指标的监控，流量的调整以及出现问题后的及时回滚。而 Flagger 就是这样一个帮助我们解决上面这些问题的开源工具。&lt;/p>
&lt;h2 id="flagger">Flagger&lt;/h2>
&lt;p>&lt;a href="https://github.com/weaveworks/flagger">Flagger&lt;/a> 是一种渐进式交付工具，可自动控制 Kubernetes 上应用程序的发布过程。通过指标监控和运行一致性测试，将流量逐渐切换到新版本，降低在生产环境中发布新软件版本导致的风险。&lt;/p>
&lt;p>Flagger 使用 Service Mesh（App Mesh，Istio，Linkerd）或 Ingress Controller（Contour，Gloo，NGINX）来实现多种部署策略（金丝雀发布，A/B 测试，蓝绿发布）。对于发布分析，Flagger 可以查询 Prometheus、Datadog 或 CloudWatch，并使用 Slack、MS Teams、Discord 和 Rocket 来发出告警通知。&lt;/p>
&lt;blockquote>
&lt;p>本文主要介绍 Flagger 使用 Nginx-Ingress 进行金丝雀发布并监控发布状态，更多内容见&lt;a href="https://docs.flagger.app/">官方文档&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://tvax4.sinaimg.cn/large/ad5fbf65ly1ggclsv45tqj21ok0skwfb.jpg" alt="Flagger NGINX Ingress Controller">&lt;/p>
&lt;h3 id="前提条件">前提条件&lt;/h3>
&lt;h4 id="版本要求">版本要求&lt;/h4>
&lt;p>安装 Flagger 需要 Kubernetes 版本高于 &lt;strong>v1.14&lt;/strong>，NGINX ingress 版本高于 &lt;strong>0.24&lt;/strong>。&lt;/p>
&lt;h4 id="安装-nginx-ingress">安装 NGINX ingress&lt;/h4>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ kubectl create ns ingress-nginx
$ helm upgrade -i nginx-ingress stable/nginx-ingress &lt;span style="color:#ed9d13">\
&lt;/span>&lt;span style="color:#ed9d13">&lt;/span>--namespace ingress-nginx &lt;span style="color:#ed9d13">\
&lt;/span>&lt;span style="color:#ed9d13">&lt;/span>--set controller.metrics.enabled=&lt;span style="color:#24909d">true&lt;/span> &lt;span style="color:#ed9d13">\
&lt;/span>&lt;span style="color:#ed9d13">&lt;/span>--set controller.podAnnotations.&lt;span style="color:#ed9d13">&amp;#34;prometheus\.io/scrape&amp;#34;&lt;/span>=&lt;span style="color:#24909d">true&lt;/span> &lt;span style="color:#ed9d13">\
&lt;/span>&lt;span style="color:#ed9d13">&lt;/span>--set controller.podAnnotations.&lt;span style="color:#ed9d13">&amp;#34;prometheus\.io/port&amp;#34;&lt;/span>=&lt;span style="color:#3677a9">10254&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装部署">安装部署&lt;/h3>
&lt;h4 id="flagger-安装">Flagger 安装&lt;/h4>
&lt;p>Flagger 提供了 Hlem 和 Kustomize 两种安装方式，这里使用 Helm 3 安装：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ helm repo add flagger https://flagger.app
$ helm upgrade -i flagger flagger/flagger &lt;span style="color:#ed9d13">\
&lt;/span>&lt;span style="color:#ed9d13">&lt;/span>--namespace ingress-nginx &lt;span style="color:#ed9d13">\
&lt;/span>&lt;span style="color:#ed9d13">&lt;/span>--set prometheus.install=&lt;span style="color:#24909d">true&lt;/span> &lt;span style="color:#ed9d13">\
&lt;/span>&lt;span style="color:#ed9d13">&lt;/span>--set &lt;span style="color:#40ffff">meshProvider&lt;/span>=nginx &lt;span style="color:#ed9d13">\
&lt;/span>&lt;span style="color:#ed9d13">&lt;/span>--set slack.url=https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK &lt;span style="color:#ed9d13">\
&lt;/span>&lt;span style="color:#ed9d13">&lt;/span>--set slack.channel=flagger &lt;span style="color:#ed9d13">\
&lt;/span>&lt;span style="color:#ed9d13">&lt;/span>--set slack.user=flagger
&lt;/code>&lt;/pre>&lt;/div>&lt;p>值得注意的是这里我选择了 Slack 作为通知软件，需要在自己的 &lt;code>#channel&lt;/code> 内新增一个 APP，并将该 APP 的 &lt;code>url&lt;/code>、&lt;code>channel&lt;/code>、&lt;code>user&lt;/code> 填入上面的命令中。这里设置的是全局通知，集群中的 Flagger 被触发后都会进行通知，当然也可以为单个 Flagger 配置专门的通知，这里就不做过多介绍，详情见&lt;a href="https://docs.flagger.app/usage/alerting">官方文档&lt;/a>。&lt;/p>
&lt;h4 id="示例安装">示例安装&lt;/h4>
&lt;p>新建测试 namespace：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ kubectl create ns &lt;span style="color:#24909d">test&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>部署示例 deployment 和 horizontal pod autoscaler：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ kubectl apply -k github.com/weaveworks/flagger//kustomize/podinfo
&lt;/code>&lt;/pre>&lt;/div>&lt;p>部署负载测试器，以便在金丝雀发布时进行流量分析：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ helm upgrade -i flagger-loadtester flagger/loadtester --namespace=&lt;span style="color:#24909d">test&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>部署 ingress，这里的 &lt;code>app.example.com&lt;/code> 需要改成你自己的域名，如果是在本地进行测试，则修改本机和负载测试器所在节点的 &lt;code>/ect/hosts&lt;/code>，将其指向你的 ADDRESS，否则将无法进行流量分析，导致部署失败。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#6ab825;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#666"> &lt;/span>networking.k8s.io/v1beta1&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">kind&lt;/span>:&lt;span style="color:#666"> &lt;/span>Ingress&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>podinfo&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">namespace&lt;/span>:&lt;span style="color:#666"> &lt;/span>test&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">labels&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">app&lt;/span>:&lt;span style="color:#666"> &lt;/span>podinfo&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">annotations&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">kubernetes.io/ingress.class&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#ed9d13">&amp;#34;nginx&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">spec&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">rules&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">host&lt;/span>:&lt;span style="color:#666"> &lt;/span>app.example.com&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">http&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">paths&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">backend&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">serviceName&lt;/span>:&lt;span style="color:#666"> &lt;/span>podinfo&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">servicePort&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#3677a9">80&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将以上内容另存为 &lt;code>podinfo-ingress.yaml&lt;/code>，然后应用：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ kubectl apply -f ./podinfo-ingress.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建一个 Canary 资源：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#6ab825;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#666"> &lt;/span>flagger.app/v1beta1&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">kind&lt;/span>:&lt;span style="color:#666"> &lt;/span>Canary&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>podinfo&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">namespace&lt;/span>:&lt;span style="color:#666"> &lt;/span>test&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">spec&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">provider&lt;/span>:&lt;span style="color:#666"> &lt;/span>nginx&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># deployment reference&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">targetRef&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#666"> &lt;/span>apps/v1&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">kind&lt;/span>:&lt;span style="color:#666"> &lt;/span>Deployment&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>podinfo&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># ingress reference&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">ingressRef&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#666"> &lt;/span>networking.k8s.io/v1beta1&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">kind&lt;/span>:&lt;span style="color:#666"> &lt;/span>Ingress&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>podinfo&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># HPA reference (optional)&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">autoscalerRef&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#666"> &lt;/span>autoscaling/v2beta1&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">kind&lt;/span>:&lt;span style="color:#666"> &lt;/span>HorizontalPodAutoscaler&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>podinfo&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># the maximum time in seconds for the canary deployment&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># to make progress before it is rollback (default 600s)&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">progressDeadlineSeconds&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#3677a9">60&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">service&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># ClusterIP port number&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">port&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#3677a9">80&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># container port number or name&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">targetPort&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#3677a9">9898&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">analysis&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># 时间间隔 (默认 60s)&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">interval&lt;/span>:&lt;span style="color:#666"> &lt;/span>10s&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># 回滚前的最大失败指标检查次数&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">threshold&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#3677a9">10&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># 路由到金丝雀副本的最大流量百分比&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># 百分比 (0-100)&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">maxWeight&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#3677a9">50&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># 金丝雀每次递增的百分比&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># 百分比 (0-100)&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">stepWeight&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#3677a9">5&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># NGINX Prometheus checks&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">metrics&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>request-success-rate&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># minimum req success rate (non 5xx responses)&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># percentage (0-100)&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">thresholdRange&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">min&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#3677a9">99&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">interval&lt;/span>:&lt;span style="color:#666"> &lt;/span>1m&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># testing (optional)&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">webhooks&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>acceptance-test&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">type&lt;/span>:&lt;span style="color:#666"> &lt;/span>pre-rollout&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">url&lt;/span>:&lt;span style="color:#666"> &lt;/span>http://flagger-loadtester.test/&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">timeout&lt;/span>:&lt;span style="color:#666"> &lt;/span>30s&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">type&lt;/span>:&lt;span style="color:#666"> &lt;/span>bash&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">cmd&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#ed9d13">&amp;#34;curl -sd &amp;#39;test&amp;#39; http://podinfo-canary/token | grep token&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>load-test&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">url&lt;/span>:&lt;span style="color:#666"> &lt;/span>http://flagger-loadtester.test/&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">timeout&lt;/span>:&lt;span style="color:#666"> &lt;/span>5s&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">cmd&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#ed9d13">&amp;#34;hey -z 1m -q 10 -c 2 http://app.example.com/&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将以上内容另存为 &lt;code>podinfo-canary.yaml&lt;/code>，然后应用：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ kubectl apply -f ./podinfo-canary.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>目前可以看到示例应用 &lt;code>podinfo&lt;/code> 已经安装完毕，并出现了 &lt;code>podinfo&lt;/code> 和 &lt;code>podinfo-primary&lt;/code> 两个版本，并且 &lt;code>http://app.example.com/&lt;/code> 已经可以访问：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ kubectl get deploy,svc,ing -n &lt;span style="color:#24909d">test&lt;/span>
NAME READY UP-TO-DATE AVAILABLE AGE
deployment.apps/flagger-loadtester 1/1 &lt;span style="color:#3677a9">1&lt;/span> &lt;span style="color:#3677a9">1&lt;/span> 29h
deployment.apps/podinfo 0/0 &lt;span style="color:#3677a9">0&lt;/span> &lt;span style="color:#3677a9">0&lt;/span> 29h
deployment.apps/podinfo-primary 2/2 &lt;span style="color:#3677a9">2&lt;/span> &lt;span style="color:#3677a9">2&lt;/span> 29s
NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE
service/flagger-loadtester ClusterIP 10.43.116.74 &amp;lt;none&amp;gt; 80/TCP 29h
service/podinfo ClusterIP 10.43.155.193 &amp;lt;none&amp;gt; 80/TCP 9s
service/podinfo-canary ClusterIP 10.43.194.226 &amp;lt;none&amp;gt; 80/TCP 29s
service/podinfo-primary ClusterIP 10.43.254.13 &amp;lt;none&amp;gt; 80/TCP 29s
NAME HOSTS ADDRESS PORTS AGE
ingress.extensions/podinfo app.example.com 192.168.1.129,192.168.4.210 &lt;span style="color:#3677a9">80&lt;/span> 5h17m
ingress.extensions/podinfo-canary app.example.com &lt;span style="color:#3677a9">80&lt;/span> 9s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个页面会展示 &lt;code>podinfo&lt;/code> 的版本已经其正在访问的 pod 名称：&lt;/p>
&lt;p>&lt;img src="https://tva4.sinaimg.cn/large/ad5fbf65ly1ggcndtuqzsj21ha0q940s.jpg" alt="app.example.com">&lt;/p>
&lt;h3 id="自动金丝雀发布">自动金丝雀发布&lt;/h3>
&lt;p>现在起发布由 Flagger 控制，在部署新版本后，Flagger 自动将流量按照比例切换到新版本上，同时监控性能指标，例如 HTTP 请求的成功率、请求的平均持续时间和 pod 运行状态，经过分析后提升流量或者回滚，并通知到 Slack。&lt;/p>
&lt;p>&lt;img src="https://tva4.sinaimg.cn/large/ad5fbf65ly1ggcng8c8vnj21q40t6q3n.jpg" alt="自动金丝雀发布">&lt;/p>
&lt;p>通过更新镜像版本触发金丝雀部署：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ kubectl -n &lt;span style="color:#24909d">test&lt;/span> &lt;span style="color:#24909d">set&lt;/span> image deployment/podinfo &lt;span style="color:#40ffff">podinfod&lt;/span>=stefanprodan/podinfo:3.1.1
deployment.apps/podinfo image updated
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到初始化完成后已经有 5% 的流量切换到新版本了&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ kubectl -n &lt;span style="color:#24909d">test&lt;/span> describe canary/podinfo
...
Status:
Canary Weight: &lt;span style="color:#3677a9">5&lt;/span>
Conditions:
Last Transition Time: 2020-07-02T07:21:26Z
Last Update Time: 2020-07-02T07:21:26Z
Message: New revision detected, progressing canary analysis.
Reason: Progressing
Status: Unknown
Type: Promoted
Failed Checks: &lt;span style="color:#3677a9">0&lt;/span>
Iterations: &lt;span style="color:#3677a9">0&lt;/span>
Last Applied Spec: c8bdf98d5
Last Transition Time: 2020-07-02T07:22:05Z
Phase: Progressing
Tracked Configs:
Events:
Type Reason Age From Message
---- ------ ---- ---- -------
Warning Synced 10m flagger podinfo-primary.test not ready: waiting &lt;span style="color:#6ab825;font-weight:bold">for&lt;/span> rollout to finish: observed deployment generation less &lt;span style="color:#6ab825;font-weight:bold">then&lt;/span> desired generation
Warning Synced 10m flagger podinfo-primary.test not ready: waiting &lt;span style="color:#6ab825;font-weight:bold">for&lt;/span> rollout to finish: &lt;span style="color:#3677a9">0&lt;/span> of &lt;span style="color:#3677a9">2&lt;/span> updated replicas are available
Normal Synced 10m (x3 over 10m) flagger all the metrics providers are available!
Normal Synced 10m flagger Initialization &lt;span style="color:#6ab825;font-weight:bold">done&lt;/span>! podinfo.test
Normal Synced 41s flagger New revision detected! Scaling up podinfo.test
Warning Synced 31s flagger canary deployment podinfo.test not ready: waiting &lt;span style="color:#6ab825;font-weight:bold">for&lt;/span> rollout to finish: &lt;span style="color:#3677a9">0&lt;/span> of &lt;span style="color:#3677a9">1&lt;/span> updated replicas are available
Warning Synced 21s flagger canary deployment podinfo.test not ready: waiting &lt;span style="color:#6ab825;font-weight:bold">for&lt;/span> rollout to finish: &lt;span style="color:#3677a9">0&lt;/span> of &lt;span style="color:#3677a9">2&lt;/span> updated replicas are available
Warning Synced 11s flagger canary deployment podinfo.test not ready: waiting &lt;span style="color:#6ab825;font-weight:bold">for&lt;/span> rollout to finish: &lt;span style="color:#3677a9">1&lt;/span> of &lt;span style="color:#3677a9">2&lt;/span> updated replicas are available
Normal Synced 1s flagger Starting canary analysis &lt;span style="color:#6ab825;font-weight:bold">for&lt;/span> podinfo.test
Normal Synced 1s flagger Pre-rollout check acceptance-test passed
Normal Synced 1s flagger Advance podinfo.test canary weight &lt;span style="color:#3677a9">5&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 &lt;code>watch&lt;/code> 也能实时看到部署流量的权重，根据上面的设置，新版本权重大于 50% 就认为部署成功，流量将全部切换到新版本，并完成金丝雀部署：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ watch kubectl get canaries --all-namespaces
Every 2.0s: kubectl get canaries --all-namespaces guoxudongdeMacBook-Pro.local: Thu Jul &lt;span style="color:#3677a9">2&lt;/span> 15:23:35 &lt;span style="color:#3677a9">2020&lt;/span>
NAMESPACE NAME STATUS WEIGHT LASTTRANSITIONTIME
&lt;span style="color:#24909d">test&lt;/span> podinfo Progressing &lt;span style="color:#3677a9">45&lt;/span> 2020-07-02T07:23:25Z
&lt;/code>&lt;/pre>&lt;/div>&lt;p>开始部署时的 Slack 通知：&lt;/p>
&lt;p>&lt;img src="https://tvax3.sinaimg.cn/large/ad5fbf65ly1ggcnsojp0kj20kj07kdgc.jpg" alt="Slack 通知">&lt;/p>
&lt;p>页面上也能看出变化，访问到新版本的概率会越来越高，以蓝色和绿色的圆代表新版本和老版本：&lt;/p>
&lt;p>&lt;img src="https://tvax2.sinaimg.cn/large/ad5fbf65ly1ggco0nxzdrj21h80q8gnu.jpg" alt="金丝雀发布">&lt;/p>
&lt;p>发布成功后，会收到 Slack 通知：&lt;/p>
&lt;p>&lt;img src="https://tva2.sinaimg.cn/large/ad5fbf65ly1ggco2mdlphj20kq01h0sn.jpg" alt="Slack 通知">&lt;/p>
&lt;h3 id="自动回滚">自动回滚&lt;/h3>
&lt;p>当然，有自动发布就会有自动回滚，下面就通过手动触发状态码 500 异常，演示暂停发布并回滚。&lt;/p>
&lt;p>部署一个新版本：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ kubectl -n &lt;span style="color:#24909d">test&lt;/span> &lt;span style="color:#24909d">set&lt;/span> image deployment/podinfo &lt;span style="color:#40ffff">podinfod&lt;/span>=stefanprodan/podinfo:3.1.2
&lt;/code>&lt;/pre>&lt;/div>&lt;p>触发状态码 500 异常：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ watch curl http://app.example.com/status/500
&lt;/code>&lt;/pre>&lt;/div>&lt;p>等待一会儿，就可以看到部署失败并回滚：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ watch kubectl get canaries --all-namespaces
Every 2.0s: kubectl get canaries --all-namespaces guoxudongdeMacBook-Pro.local: Thu Jul &lt;span style="color:#3677a9">2&lt;/span> 15:45:24 &lt;span style="color:#3677a9">2020&lt;/span>
NAMESPACE NAME STATUS WEIGHT LASTTRANSITIONTIME
&lt;span style="color:#24909d">test&lt;/span> podinfo Failed &lt;span style="color:#3677a9">0&lt;/span> 2020-07-02T07:45:16Z
&lt;/code>&lt;/pre>&lt;/div>&lt;p>发布失败，也会收到 Slack 通知：&lt;/p>
&lt;p>&lt;img src="https://tva3.sinaimg.cn/large/ad5fbf65ly1ggcobt1f0bj20kd01vmx1.jpg" alt="失败 Slack 通知">&lt;/p>
&lt;h3 id="ab-测试">A/B 测试&lt;/h3>
&lt;p>除了加权路由，Flagger 还可以根据 HTTP 匹配条件将流量路由到新版本（当然，这个 Nginx-Ingress 的功能，Flagger 只是简化了操作）。可以根据 HTTP header 和 cookie 来定位用户并细分受众，对于需要关联会话的前端应用十分有用。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/ad5fbf65ly1ggcoglbmnyj217q0q0q3h.jpg" alt="A/B 测试">&lt;/p>
&lt;p>修改 Canary 资源：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#6ab825;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#666"> &lt;/span>flagger.app/v1beta1&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">kind&lt;/span>:&lt;span style="color:#666"> &lt;/span>Canary&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>podinfo&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">namespace&lt;/span>:&lt;span style="color:#666"> &lt;/span>test&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">spec&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">provider&lt;/span>:&lt;span style="color:#666"> &lt;/span>nginx&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># deployment reference&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">targetRef&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#666"> &lt;/span>apps/v1&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">kind&lt;/span>:&lt;span style="color:#666"> &lt;/span>Deployment&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>podinfo&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># ingress reference&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">ingressRef&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#666"> &lt;/span>networking.k8s.io/v1beta1&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">kind&lt;/span>:&lt;span style="color:#666"> &lt;/span>Ingress&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>podinfo&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># HPA reference (optional)&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">autoscalerRef&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#666"> &lt;/span>autoscaling/v2beta1&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">kind&lt;/span>:&lt;span style="color:#666"> &lt;/span>HorizontalPodAutoscaler&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>podinfo&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># the maximum time in seconds for the canary deployment&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># to make progress before it is rollback (default 600s)&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">progressDeadlineSeconds&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#3677a9">60&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">service&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># ClusterIP port number&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">port&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#3677a9">80&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># container port number or name&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">targetPort&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#3677a9">9898&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">analysis&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">interval&lt;/span>:&lt;span style="color:#666"> &lt;/span>1m&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">threshold&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#3677a9">10&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">iterations&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#3677a9">10&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">match&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># curl -H &amp;#39;X-Canary: insider&amp;#39; http://app.example.com&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">headers&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">x-canary&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">exact&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#ed9d13">&amp;#34;insider&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># curl -b &amp;#39;canary=always&amp;#39; http://app.example.com&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">headers&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">cookie&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">exact&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#ed9d13">&amp;#34;canary&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">metrics&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>request-success-rate&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">thresholdRange&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">min&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#3677a9">99&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">interval&lt;/span>:&lt;span style="color:#666"> &lt;/span>1m&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">webhooks&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>load-test&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">url&lt;/span>:&lt;span style="color:#666"> &lt;/span>http://flagger-loadtester.test/&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">timeout&lt;/span>:&lt;span style="color:#666"> &lt;/span>5s&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">cmd&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#ed9d13">&amp;#34;hey -z 1m -q 10 -c 2 -H &amp;#39;Cookie: canary=always&amp;#39; http://app.example.com/&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从上面的配置可以看到，将 headers 为 &lt;code>X-Canary: insider&lt;/code> 或 cookie 为 &lt;code>canary=always&lt;/code> 的请求路由到新版本。&lt;/p>
&lt;p>部署一个新版本：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ kubectl -n &lt;span style="color:#24909d">test&lt;/span> &lt;span style="color:#24909d">set&lt;/span> image deployment/podinfo &lt;span style="color:#40ffff">podinfod&lt;/span>=stefanprodan/podinfo:3.1.3
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以收到 Slack 通知：&lt;/p>
&lt;p>&lt;img src="https://tva4.sinaimg.cn/large/ad5fbf65gy1ggcorvilrrj20kb07wdgb.jpg" alt="A/B 测试 Slack 通知">&lt;/p>
&lt;p>正常访问，还是访问到老的 &lt;code>v3.1.1&lt;/code> 版：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ curl http://app.example.com
{
&lt;span style="color:#ed9d13">&amp;#34;hostname&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;podinfo-primary-5dc6b76bd5-8sbh8&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;version&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;3.1.1&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;revision&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;7b6f11780ab1ce8c7399da32ec6966215b8e43aa&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;color&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;#34577c&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;logo&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;https://raw.githubusercontent.com/stefanprodan/podinfo/gh-pages/cuddle_clap.gif&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;message&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;greetings from podinfo v3.1.1&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;goos&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;linux&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;goarch&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;amd64&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;runtime&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;go1.13.1&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;num_goroutine&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;11&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;num_cpu&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;6&amp;#34;&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>请求添加指定 header，访问到新的 &lt;code>v3.1.3&lt;/code> 版：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ curl -H &lt;span style="color:#ed9d13">&amp;#39;X-Canary: insider&amp;#39;&lt;/span> http://app.example.com
{
&lt;span style="color:#ed9d13">&amp;#34;hostname&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;podinfo-58bdd78d6f-m9bsc&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;version&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;3.1.3&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;revision&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;7b6f11780ab1ce8c7399da32ec6966215b8e43aa&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;color&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;#34577c&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;logo&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;https://raw.githubusercontent.com/stefanprodan/podinfo/gh-pages/cuddle_clap.gif&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;message&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;greetings from podinfo v3.1.3&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;goos&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;linux&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;goarch&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;amd64&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;runtime&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;go1.13.1&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;num_goroutine&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;10&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;num_cpu&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;6&amp;#34;&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>请求添加指定 cookie，访问到新的 &lt;code>v3.1.3&lt;/code> 版：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ curl -b &lt;span style="color:#ed9d13">&amp;#39;canary=always&amp;#39;&lt;/span> http://app.example.com
{
&lt;span style="color:#ed9d13">&amp;#34;hostname&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;podinfo-58bdd78d6f-m9bsc&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;version&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;3.1.3&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;revision&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;7b6f11780ab1ce8c7399da32ec6966215b8e43aa&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;color&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;#34577c&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;logo&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;https://raw.githubusercontent.com/stefanprodan/podinfo/gh-pages/cuddle_clap.gif&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;message&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;greetings from podinfo v3.1.3&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;goos&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;linux&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;goarch&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;amd64&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;runtime&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;go1.13.1&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;num_goroutine&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;10&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;num_cpu&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;6&amp;#34;&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在浏览器中访问也能得到相同的结果：&lt;/p>
&lt;p>&lt;img src="https://tva3.sinaimg.cn/large/ad5fbf65gy1ggcoy65l47j20yb0dvq49.jpg" alt="添加 cookie 在浏览器中访问">&lt;/p>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>最早了解 Flagger 其实是因为其与 Istio 的关系，Flagger 默认的 meshProvider 就是 Istio。但是在深入了解后，发现其对市面上常见的 Service Mesh 和 Ingress Controller 都有较好的支持，通过与 Prometheus 以及负载测试器的配合可以进行细粒度的分析，从而提高了发布质量，同时还降低了人工操作出错的可能性。&lt;/p>
&lt;p>最近 &lt;a href="https://oam.dev/">OAM 社区&lt;/a>也放出了基于 Flagger 的部署 Trait 的示例，相信之后与 OAM 结合使用可以在持续部署和应用管理领域发挥更大的作用。&lt;/p>
&lt;p>想了解 OAM 可以查看我之前的文章：&lt;a href="../start-oam">《以应用为中心：开放应用模型（OAM）初探》&lt;/a>。&lt;/p>
&lt;p>&lt;img src="https://tva3.sinaimg.cn/large/ad5fbf65gy1gfm3j2vo79g20b90b9x6r.gif" alt="">&lt;/p></description></item><item><title>Post: 告别手写 Helm Chart README</title><link>https://guoxudong.io/post/helm-docs/</link><pubDate>Fri, 08 May 2020 11:20:01 +0800</pubDate><guid>https://guoxudong.io/post/helm-docs/</guid><description>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>随着云原生应用的普及，Helm 的作用也日益凸显，越来越多的云原生应用以 Helm Chart 的形式发布，可以说现在如果没有一个 Helm Chart 都不好意思说自己是云原生应用。&lt;/p>
&lt;p>一个好的应用必定有一套好的文档，文档的质量往往和代码的质量成正比。而 Helm Chart 中的 &lt;code>README.md&lt;/code> 文件就承担了文档的作用，该文件会介绍这个 Helm Chart 的基本信息、使用方式以及参数配置等，用户可以通过该文档的指引，配置符合自己需求的参数，最终完成云原生应用的部署。&lt;/p>
&lt;p>但这也给云原生应用的开发者提出了挑战，开发者不但需要把 &lt;code>value.yaml&lt;/code> 和 &lt;code>Chart.yaml&lt;/code> 等文件的参数以 Markdown 的形式搬运到 &lt;code>README.md&lt;/code> 文件中，同时还要将参数的默认值，以及介绍填入表格中。但如果参数出现了变动，往往无法及时更新文档。这就导致了用户明明根据文档配置了参数，但是部署的效果就是无法达到预期。&lt;/p>
&lt;h2 id="helm-docs">Helm-docs&lt;/h2>
&lt;p>helm-docs 可以根据 charts 内容自动生成 markdown 文件。该文件会包含有关 charts 的元数据，以及 &lt;code>value.yaml&lt;/code> 中的参数，同时还可以引用子模板（默认为 &lt;code>README.md.gotmpl&lt;/code>），进一步定制生成的内容。&lt;/p>
&lt;h3 id="安装">安装&lt;/h3>
&lt;p>&lt;a href="https://github.com/norwoodj/helm-docs">helm-docs&lt;/a> 使用 golang 开发，支持多平台：&lt;/p>
&lt;p>&lt;strong>MacOS&lt;/strong>&lt;/p>
&lt;p>可以使用 homebrew 安装：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">brew install norwoodj/tap/helm-docs
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>下载可执行文件&lt;/strong>&lt;/p>
&lt;p>到 &lt;a href="https://github.com/norwoodj/helm-docs/releases">release&lt;/a> 页面下载对应平台的可执行文件。&lt;/p>
&lt;h3 id="快速开始">快速开始&lt;/h3>
&lt;p>&lt;strong>直接使用可执行文件&lt;/strong>&lt;/p>
&lt;p>使用方法也很简单，直接进入到 Chart 所在目录，执行命令：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">helm-docs
&lt;span style="color:#999;font-style:italic"># 或者&lt;/span>
helm-docs --dry-run &lt;span style="color:#999;font-style:italic"># 不生成 README.md 文件，而是将生成的内容打印到控制台&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>使用 docker&lt;/strong>&lt;/p>
&lt;p>如果不想安装可执行文件，也可以使用 docker，将 Chart 目录挂载到 docker 镜像中，实现相同的效果：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">docker run -v &lt;span style="color:#ed9d13">&amp;#34;&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">$(&lt;/span>&lt;span style="color:#24909d">pwd&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">)&lt;/span>&lt;span style="color:#ed9d13">:/helm-docs&amp;#34;&lt;/span> jnorwood/helm-docs:latest
&lt;span style="color:#999;font-style:italic"># 或者&lt;/span>
docker run -v &lt;span style="color:#ed9d13">&amp;#34;&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">$(&lt;/span>&lt;span style="color:#24909d">pwd&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">)&lt;/span>&lt;span style="color:#ed9d13">:/helm-docs&amp;#34;&lt;/span> jnorwood/helm-docs:latest --dry-run
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="进阶实践">进阶实践&lt;/h3>
&lt;p>下面就以我的开源项目 &lt;a href="https://github.com/sunny0826/cms-grafana-builder">cms-grafana-builder&lt;/a> 为例，讲解 helm-docs 的一些进阶使用。&lt;/p>
&lt;p>&lt;strong>添加参数说明&lt;/strong>&lt;/p>
&lt;p>helm-docs 可以通过 &lt;code>value.yaml&lt;/code> 中的注释生成参数说明，注释格式如下所示，&lt;code>--&lt;/code> 后的内容会自动填充到 Chart Values 的 Description 中：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#999;font-style:italic"># access_key_id -- Aliyun Access Key Id.&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">access_key_id&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#ed9d13">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># access_secret -- Aliyun Access Secret.&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">access_secret&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#ed9d13">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># region_id -- Aliyun Region Id.&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">region_id&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#ed9d13">&amp;#34;cn-shanghai&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># password -- Grafana admin password.&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">password&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#ed9d13">&amp;#34;admin&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">image&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># image.repository -- Image source repository name.&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">repository&lt;/span>:&lt;span style="color:#666"> &lt;/span>grafana/grafana&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># image.pullPolicy -- Image pull policy.&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">pullPolicy&lt;/span>:&lt;span style="color:#666"> &lt;/span>IfNotPresent&lt;span style="color:#666">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>自定义模板&lt;/strong>&lt;/p>
&lt;p>可以新建 &lt;code>README.md.gotmpl&lt;/code> 模板来进一步定制 &lt;code>README.md&lt;/code> 的输出样式。&lt;/p>
&lt;p>&lt;code>README.md.gotmpl&lt;/code> 文件的内容如下，可以在模板中插入 Markdown 来充实 &lt;code>README.md&lt;/code> 的内容，以及改变展示内容的顺序：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-golang" data-lang="golang">{{ template &lt;span style="color:#ed9d13">&amp;#34;chart.header&amp;#34;&lt;/span> . }}
{{ template &lt;span style="color:#ed9d13">&amp;#34;chart.description&amp;#34;&lt;/span> . }}
{{ template &lt;span style="color:#ed9d13">&amp;#34;chart.versionLine&amp;#34;&lt;/span> . }}
{{ template &lt;span style="color:#ed9d13">&amp;#34;chart.sourceLinkLine&amp;#34;&lt;/span> . }}
&lt;span style="color:#a61717;background-color:#e3d2d2">##&lt;/span> Introduction
This chart helps you run a grafana server that include aliyun cms dashboard.
{{ template &lt;span style="color:#ed9d13">&amp;#34;chart.requirementsSection&amp;#34;&lt;/span> . }}
{{ template &lt;span style="color:#ed9d13">&amp;#34;chart.valuesSection&amp;#34;&lt;/span> . }}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>更多内容和示例，详见 &lt;a href="https://github.com/norwoodj/helm-docs">https://github.com/norwoodj/helm-docs&lt;/a>&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>helm-docs 可以帮助很多像我这样需要维护多个 Helm Chart 的开发者，在更新完或新建 Chart 以后，使用 &lt;code>helm-docs&lt;/code> 来自动生成 &lt;code>README.md&lt;/code> 文件，无需逐个寻找和修改，甚至将其集成到 CI 流水线中，自动生成最新的 &lt;code>README.md&lt;/code>，保证文档和代码的一致。&lt;/p></description></item><item><title>Post: 去指挥你的舰队吧！体验使用 Fleet 批量管理 K8S 集群</title><link>https://guoxudong.io/post/rancher-fleet/</link><pubDate>Thu, 23 Apr 2020 14:03:53 +0800</pubDate><guid>https://guoxudong.io/post/rancher-fleet/</guid><description>
&lt;h2 id="前言">前言&lt;/h2>
&lt;div class="alert alert-primary" role="alert">
2020年4月3日，Rancher Labs 宣布推出全新开源项目 Fleet，致力于为用户提供海量 Kubernetes 集群的集中管理体验。
&lt;/div>
&lt;p>最早听说到这个消息时，我还是很疑惑的，Fleet 不是 CoreOS 早已经停止维护的一个项目吗？怎么又和 Rancher Labs 扯上了关系？&lt;/p>
&lt;p>**“为用户提供海量 Kubernetes 集群的集中管理体验”**这句话是否言过其实：&lt;/p>
&lt;ul>
&lt;li>“海量”这个量到底有多大？&lt;/li>
&lt;li>又有多少公司或团队有管理海量的 Kubernetes 集群的需求？&lt;/li>
&lt;li>又是怎么一个&lt;strong>集中管理&lt;/strong>法？&lt;/li>
&lt;/ul>
&lt;p>带着这些疑问，我仔细了解了一下 Fleet 这个开源项目。&lt;/p>
&lt;h2 id="fleet">Fleet&lt;/h2>
&lt;p>首先，这里的 Fleet 是一个新项目，起这个名字应该算是一种致敬，经过了解后我个人觉得这个名字起的还是挺贴切的，比一大波 KubeXXX 有创意多了。&lt;/p>
&lt;blockquote>
&lt;p>“我一直是它的忠实粉丝，将这一项目命名为 Fleet 也包含了我的私心。”Darren Shepherd 解释道：“所以我希望重新使用 Fleet 这一名字，这是对这个非常出色的容器领域早期项目的致敬。同时，对于推动 Kubernetes 集群管理的演进，我们感到十分兴奋及万分期待。”&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>&amp;mdash; 摘自 RancherLabs 官方微信公众号《Rancher开源Fleet：业界首个海量K8S集群管理项目》&lt;/p>
&lt;/blockquote>
&lt;p>顾名思义 Fleet 是“舰队”的意思，而 Kubernetes 在希腊语意为 “舵手”。从名称上看，Fleet 的目标就是管理或是指挥众多 Kubernetes 集群。而在了解这个项目时，我发现了这个项目和 Rancher Labs 另一个受欢迎项目 &lt;a href="https://k3s.io/">k3s&lt;/a> 有个千丝万缕的联系，甚至在我看来 Fleet 可能就是就是为了管理众多 k3s 集群而生的，是 Rancher Labs 布局边缘计算和 IoT 领域的重要组成部分。&lt;/p>
&lt;p>k3s 是一款轻量级的 Kubernetes 集群，主要面向边缘计算和 IOT 领域，相比原生 Kubernetes，k3s 体量更轻、部署简单且快速，同时还具有完整的 Kubernetes 体验。可以说只要是 Linux 系统（配合周边工具甚至可以运行在 Mac 和 Windows 系统），无论是树莓派、各种开发板还是 PC 机，都可以独立运行起 k3s，&lt;strong>这也为运行海量 Kubernetes 集群&lt;/strong>提供了可能。以汽车为例，我们可以为每一辆汽车都部署一个 k3s 集群，所有汽车相关的软件（导航、广播甚至是无人驾驶程序）都部署在 k3s 集群中，每次这些软件发布新版本，只需使用 Fleet 进行批量操作该种车型的所有 k3s 集群即可，无需将车开回 4S 店进行手动更新。&lt;/p>
&lt;div class="alert alert-primary" role="alert">
联系美国空军是 Kubernetes 与 Istio 项目的重要用户，这种实践可能早就开始了。
&lt;/div>
&lt;p>解释了海量 Kubernetes 集群的疑问，下面就从 Fleet 的架构入手，讲讲如何&lt;strong>集中管理&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/ad5fbf65ly1ge3o40xe41j20qx0ljdm7.jpg" alt="">&lt;/p>
&lt;p>Fleet 包含&lt;code>Manager&lt;/code>和&lt;code>agent&lt;/code>，&lt;code>Manager&lt;/code>所在集群作为控制平面管理所有&lt;code>agent&lt;/code>集群，同时 Fleet 根据 Kubernetes 部署 Pod 的模型，定义了一个 Bundles 对象，并且提供了一种内置机制，可以使用诸如&lt;code>Helm&lt;/code>和&lt;code>Kustomize&lt;/code>等行业标准工具为每个目标集群定制 Bundles，在我看来这种模式以及&lt;code>bundle.yaml&lt;/code>的写法都和&lt;code>Kustomize&lt;/code>很像(套娃行为？)&amp;hellip;一旦用户在集群之间部署了 Bundles，Fleet 就会主动监视资源是否已就绪，以及是否被更改过。总的来说就是通过部署 Bundles，就可以将部署内容批量分发到所有目标集群，从而达到&lt;strong>集中管理&lt;/strong>的目的。&lt;/p>
&lt;h2 id="尝鲜体验">尝鲜体验&lt;/h2>
&lt;p>说那么多其实意义不大，好不好用，只有试过才知道。这里使用的 Fleet 版本为&lt;code>v0.2.0&lt;/code>，是目前的最新版本。&lt;/p>
&lt;p>&lt;strong>下载 CLI 工具&lt;/strong>&lt;/p>
&lt;p>首先需要下载&lt;code>fleet&lt;/code>的 CLI 工具，这里的体验和 k3s 类似，都是直接&lt;code>curl&lt;/code> GitHub 上的安装脚本并执行：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ curl -sfL https://raw.githubusercontent.com/rancher/fleet/master/install.sh | sh -
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>部署控制平面&lt;/strong>&lt;/p>
&lt;p>使用 CLI 工具将&lt;code>Fleet Manager&lt;/code>部署到 Kubernetes 集群上：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#999;font-style:italic"># Kubeconfig should point to Manager cluster&lt;/span>
$ fleet install manager | kubectl apply -f -
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>生成 Cluster group token&lt;/strong>&lt;/p>
&lt;p>到这控制平面就部署好了，接下来部署&lt;code>agent&lt;/code>目标集群。这里生成的其实是一个 yaml 文件，内容包含 fleet 需要的 RBAC 权限和 fleet-agent 的 Deployment：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#999;font-style:italic"># Kubeconfig should point to Manager cluster&lt;/span>
$ fleet install agent-token &amp;gt; token
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>目标集群注册&lt;/strong>&lt;/p>
&lt;p>将需要纳管的目标集群加入到 fleet 中，&lt;strong>注意&lt;/strong>：这里需要将 kubeconfig 切换到目标集群，也就是需要部署&lt;code>agent&lt;/code>的集，每个需要注册的集群都要部署&lt;code>agent&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#999;font-style:italic"># Kubeconfig should point to AGENT cluster&lt;/span>
$ kubectl apply -f token
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>部署 bundles&lt;/strong>&lt;/p>
&lt;p>这里就是向多个集群同时部署 bundles，使用方法也和&lt;code>Kustomize&lt;/code>类似（&lt;code>example&lt;/code> 目录是 fleet 官方仓库中的示例目录）：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#999;font-style:italic"># Kubeconfig should point to Manager cluster&lt;/span>
$ fleet apply ./examples/helm-kustomize
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>查看状态&lt;/strong>&lt;/p>
&lt;p>现在就可以查看所有集群 bundles 的状态了，这里可以看到 bundles 在多个集群都部署成功了（这里是我起的两个 k3s 集群做的测试）：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ kubectl get fleet
NAME CLUSTER-COUNT BUNDLES-READY BUNDLES-DESIRED STATUS
clustergroup.fleet.cattle.io/default &lt;span style="color:#3677a9">2&lt;/span> &lt;span style="color:#3677a9">3&lt;/span> &lt;span style="color:#3677a9">4&lt;/span> Modified: &lt;span style="color:#3677a9">1&lt;/span> (helm-kustomize )
NAME CLUSTERS-READY CLUSTERS-DESIRED STATUS
bundle.fleet.cattle.io/fleet-agent &lt;span style="color:#3677a9">2&lt;/span> &lt;span style="color:#3677a9">2&lt;/span>
bundle.fleet.cattle.io/helm-kustomize &lt;span style="color:#3677a9">1&lt;/span> &lt;span style="color:#3677a9">2&lt;/span> Modified: &lt;span style="color:#3677a9">1&lt;/span> (default-default-group/cluster-5a186072-acbd-4f54-8f22-fb1651ce902f )
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>总的来说，Fleet 的架构简洁且十分轻量，部署方式简单，使用&lt;code>YAML&lt;/code>、&lt;code>Helm&lt;/code>、&lt;code>Kustomez&lt;/code>都可以进行资源的描述和配置，甚至可以使用&lt;code>Helm&lt;/code>+&lt;code>Kustomeze&lt;/code>的模式，部署体验不错。&lt;/p>
&lt;p>但遗憾的是，目前 Fleet 还处于项目早期，实践也仅限于尝鲜体验，并不能用于生产环境，项目 README 中还专门提到了&lt;strong>目前 Fleet 仅适用于 10 个集群以下的小规模部署&lt;/strong>。目前文档不足且项目维护人员并不积极，文档勘误的 &lt;a href="https://github.com/rancher/fleet/pull/32">RP&lt;/a> 和相关 ISSUE 也没有得到相关的反馈。项目是做到了业界首个，但是要真正生产可用甚至做到业界第一还有很长的一段路要走。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/rancher/fleet">Fleet - Github&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/byErGqVBtm4kdv58OZFt_w">Rancher开源Fleet：业界首个海量K8S集群管理项目 - RancherLabs&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Post: Katacoda：免费学习 Kubernetes 利器</title><link>https://guoxudong.io/post/katacoda-k8s/</link><pubDate>Fri, 27 Mar 2020 15:57:11 +0800</pubDate><guid>https://guoxudong.io/post/katacoda-k8s/</guid><description>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>最近 ServiceMesher 社区重启了&lt;a href="https://github.com/servicemesher/istio-handbook">《Istio 服务网格进阶实战》&lt;/a> 的编写，我也作为编委会成员参与其中。该书的实践项目都基于 Istio 1.5 版本以及 Katacoda 提供的 Kubernetes 环境完成。由于实践部分都要使用 Katacoda，介绍 Katacoda 这章需要先完成，为其他参与编写实践篇的作者提供参考。&lt;/p>
&lt;h2 id="katacoda">Katacoda&lt;/h2>
&lt;p>Katacoda 是一个面向软件工程师的交互式学习和培训平台，可在浏览器中使用真实环境学习和测试新技术，帮助开发人员学习，并掌握最佳实践。该平台于 2019 年 11 月被 O&amp;rsquo;Reilly 收购。&lt;/p>
&lt;p>Katacoda 可以快速的提供一套完整的临时环境，并在使用后将其回收。用户可以根据设计好的引导步骤，通过浏览器上的终端界面操作一套完整的环境，一步步的学习和实践。尤其是在学习 Kubernetes 这种复杂的应用时，单单是创建一个集群就要花去不少时间，同时消耗的资源也令一些初学者望而生畏，Katacoda 的出现很好的解决了这些问题。课程设计者可以定制应用程序所需环境，并设计循序渐进的指导路径，旨在确保用户以最佳方式学习。&lt;/p>
&lt;p>在 Katacoda 每个用户都可以免费的学习和创建课程，其中：&lt;/p>
&lt;ul>
&lt;li>Course：课程，可包含一系列的 scenarios。
&lt;ul>
&lt;li>官方教程入口：&lt;a href="https://katacoda.com/scenario-examples/scenarios/create-course">https://katacoda.com/scenario-examples/scenarios/create-course&lt;/a>&lt;/li>
&lt;li>汉化教程入口：&lt;a href="https://katacoda.com/guoxudong/courses/katacoda-example/create-course">https://katacoda.com/guoxudong/courses/katacoda-example/create-course&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Scenarios：场景、方案。
&lt;ul>
&lt;li>官方教程入口：&lt;a href="https://katacoda.com/scenario-examples/scenarios/create-scenario-101">https://katacoda.com/scenario-examples/scenarios/create-scenario-101&lt;/a>&lt;/li>
&lt;li>汉化教程入口：&lt;a href="https://katacoda.com/guoxudong/courses/katacoda-example/katacoda-create-scenarios">https://katacoda.com/guoxudong/courses/katacoda-example/katacoda-create-scenarios&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="使用-katacoda-学习">使用 Katacoda 学习&lt;/h2>
&lt;p>Katacoda 提供了非常便利的学习方式，用户只需要打开相应课程，就可以跟着课程设计者的说明，按照设计好的步骤一步步完成学习。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>介绍会标明课程的难度和需要的时间，帮助用户了解该课程的基本信息：
&lt;img src="https://tvax1.sinaimg.cn/large/ad5fbf65gy1gd8k9b4jwoj21ha0q7wha.jpg" alt="image">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>进入课程，左侧是该步骤说明，右侧是一个已经准备好的终端，直接可以使用：
&lt;img src="https://tvax2.sinaimg.cn/large/ad5fbf65gy1gd8kdmfr3ej21h90qeq8s.jpg" alt="image">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>之后就是跟着步骤说明，一步步的完成学习即可：
&lt;img src="https://tva3.sinaimg.cn/large/ad5fbf65gy1gd8kh1jcs1j21hb0q5do7.jpg" alt="image">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="创建课程">创建课程&lt;/h2>
&lt;p>既然可以学习别人设计好的课程，那么也可以自己设计课程，以供用户学习。&lt;/p>
&lt;h3 id="新建仓库">新建仓库&lt;/h3>
&lt;p>Katacoda 需要注册账号登录，这里直接使用 GitHub 账号登录即可，毕竟之后创建的方案都是存放在 GitHub 上的。&lt;/p>
&lt;p>这里推荐在页面新建仓库，访问 &lt;a href="https://www.katacoda.com/teach/git-hosted-scenarios">https://www.katacoda.com/teach/git-hosted-scenarios&lt;/a> ，点击 &lt;code>Automatically Create and Configure Github Repository&lt;/code> 按钮，Katacoda 会自动在您的 Github 中创建一个名为 &lt;code>katacoda-scenarios&lt;/code> 的仓库，并自动为您配置 Webhook，每次更新该仓库时，都会自动更新您 Katacoda 中课程的内容。&lt;/p>
&lt;p>&lt;img src="https://tvax3.sinaimg.cn/large/ad5fbf65gy1gd73rov21ij219q0pl42u.jpg" alt="katacoda 新建仓库页面">&lt;/p>
&lt;p>创建完成后，就可以在您的 Github 上找到名为 &lt;code>katacoda-scenarios&lt;/code> 的代码仓库。&lt;/p>
&lt;h3 id="scenarios">Scenarios&lt;/h3>
&lt;p>Scenarios 即为方案、场景，由一组 Markdown、bash 脚本和一个 JSON 文件组成，这些文件保存了该 Scenarios 的所有配置。&lt;/p>
&lt;p>Katacoda 官方提供了 CLI 工具，帮助您创建 Scenarios。&lt;/p>
&lt;h4 id="安装-cli">安装 CLI&lt;/h4>
&lt;p>通过 npm 命令安装 &lt;code>npm i katacoda-cli --global&lt;/code>。&lt;/p>
&lt;p>命令遵循语法的是 &lt;code>$ katacoda COMMAND&lt;/code>&lt;/p>
&lt;p>安装完成后，可以通过运行命令 &lt;code>katacoda --help&lt;/code> 查看帮助信息。&lt;/p>
&lt;h4 id="创建-scenarios-目录">创建 Scenarios 目录&lt;/h4>
&lt;p>例如，要创建新的方案，可以通过运行命令 &lt;code>katacoda scenarios:create&lt;/code>，CLI 将会提示一些信息，帮助您创建方案：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Friendly URL:&lt;/strong> 此处可输入 &lt;code>test-scenario&lt;/code>，该属性将确定 scenarios 文件夹的名称，以及用来访问他的 URL。因此，该属性不能包括空格，需要是小写字母等。例如，如果您的用户名是 test-username 并且您的方案称为 test-scenario（如建议的那样），用于在平台中指向该方案的URL将为 &lt;a href="https://katacoda.com/test-username/scenarios/test-scenario/">https://katacoda.com/test-username/scenarios/test-scenario/&lt;/a>&lt;/li>
&lt;li>&lt;strong>Title:&lt;/strong> 方案的标题，将会显示在简介上&lt;/li>
&lt;li>&lt;strong>Description:&lt;/strong> 方案的描述，将会显示在简介上&lt;/li>
&lt;li>&lt;strong>Difficulty level:&lt;/strong> 难度级别，将会显示在简介上&lt;/li>
&lt;li>&lt;strong>Estimated time:&lt;/strong> 估计完成的时间，将会显示在简介上&lt;/li>
&lt;li>&lt;strong>Number of steps:&lt;/strong> 方案的步骤数。CLI 将会为您的所有步骤创建文件&lt;/li>
&lt;li>&lt;strong>Image:&lt;/strong> 确定适用于您的方案的基本软件。例如，如果您需要 docker，java，go 等作为前提条件。更多相关信息，请阅读 &lt;a href="https://katacoda.com/docs/scenarios/environments">https://katacoda.com/docs/scenarios/environments&lt;/a>&lt;/li>
&lt;li>&lt;strong>Layout:&lt;/strong> 它将确定方案界面元素的配置。例如，如果您只想显示终端，或编辑器+终端等形式，更多相关信息，请阅读 &lt;a href="https://katacoda.com/docs/scenarios/layouts">https://katacoda.com/docs/scenarios/layouts&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>输入这些信息，CLI 将帮您创建一个文件夹，其中引入了 &lt;em>&lt;strong>friendly URL&lt;/strong>&lt;/em> 的名称，并将在该文件夹内创建方案所需的文件。&lt;/p>
&lt;h4 id="编辑-scenarios">编辑 Scenarios&lt;/h4>
&lt;p>Scenarios 目录创建好之后，可以看到目录的结构：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">.
├── finish.md
├── index.json
├── intro.md
├── step1.md
├── step2.md
├── step3.md
├── step4.md
└── step5.md
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>index.json&lt;/code> ：文件中定义了标题、描述、步骤顺序、UI 布局以及所需环境，内容与您使用 CLI 工具创建时输入的是一致的，如果想对输入的内容进行修改，也可以在这里修改&lt;/li>
&lt;li>&lt;code>intro.md&lt;/code>：介绍页，用来介绍您这个 Scenarios&lt;/li>
&lt;li>&lt;code>finish.md&lt;/code> ：结束页&lt;/li>
&lt;li>&lt;code>step1-setpN.md&lt;/code>：步骤介绍，数目与您使用 CLI 工具创建 Scenarios 时输入的数目相同&lt;/li>
&lt;/ul>
&lt;h3 id="上传">上传&lt;/h3>
&lt;p>将创建的 Scenarios 移动到之前创建的 git 项目中。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ git add .
$ git commit -m &lt;span style="color:#ed9d13">&amp;#34;New Scenarios&amp;#34;&lt;/span>
$ git push origin master
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上传成功后，在 &lt;strong>Your Profile&lt;/strong> 页面就可以看到您上传的课程。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>Katacoda 是一个面向软件工程师的交互式学习和培训平台，开发人员根据产品特色设计学习流程，方便用户的学习；学习者则无需关心环境的搭建与依赖的安装，通过开发人员设计的最佳实践来进行学习，快速又高效。&lt;strong>最重要的是，它是免费的！白嫖的东西又有谁不喜欢呢？&lt;/strong>&lt;/p>
&lt;p>同时也欢迎各位朋友一起参与到&lt;a href="https://github.com/servicemesher/istio-handbook">《Istio 服务网格进阶实战》&lt;/a> 的编撰中，和 ServiceMesher 社区的朋友一起完成这部开源书籍。&lt;/p></description></item><item><title>Post: Kt Connect：研发侧利器，本地连通 Kubernetes 集群内网</title><link>https://guoxudong.io/post/alibaba-kt-connect/</link><pubDate>Tue, 24 Mar 2020 09:14:06 +0800</pubDate><guid>https://guoxudong.io/post/alibaba-kt-connect/</guid><description>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>随着 Kubernetes 的普及，越来越多的应用被容器化，并部署到 Kubernetes 上。随之而来的问题是当容器中发生错误时，对错误的定位和调试也变得很复杂。当一个工具给你带来便利时，它也可能给你带来另一些麻烦。&lt;/p>
&lt;p>那么有没有工具可以在本地联通 Kubernetes 集群并进行调试呢？当然是有的，这里就介绍一款研发侧利器：&lt;code>Kt Connect&lt;/code>&lt;/p>
&lt;h2 id="kt-connect">Kt Connect&lt;/h2>
&lt;p>&lt;code>Kt Connect&lt;/code> 是阿里巴巴开源的一款云原生协同开发测试解决方案，目前的功能包括：&lt;/p>
&lt;ul>
&lt;li>直接访问 Kubernetes 集群&lt;/li>
&lt;li>转发集群流量到本地&lt;/li>
&lt;li>Service Mesh 支持&lt;/li>
&lt;li>基于 SSH 的轻量级 VPN 网络&lt;/li>
&lt;li>作为 kubectl 插件，集成到 Kubectl&lt;/li>
&lt;/ul>
&lt;p>（以上内容来自&lt;a href="https://alibaba.github.io/kt-connect/#/zh-cn/">官方文档&lt;/a>）&lt;/p>
&lt;p>目前使用下来最实用的功能就是&lt;strong>直接连接 Kubernetes 网络&lt;/strong>实现在本地使用 k8s 内网域名调用 Kubernetes 集群内的服务以及&lt;strong>将 Kubernetes 集群中的流量转发到本地&lt;/strong>，作用类似于一个 VPN，将本地网络与 Kubernetes 集群网络连接。
&lt;img src="https://tvax1.sinaimg.cn/large/ad5fbf65gy1gd4wu5p3rmj20pb0dl75m.jpg" alt="">&lt;/p>
&lt;h2 id="安装">安装&lt;/h2>
&lt;p>&lt;code>Kt Connect&lt;/code> 使用 Go 开发，支持 Mac、Linux 和 Windows，安装方式也很简单&lt;/p>
&lt;p>前往&lt;a href="https://github.com/alibaba/kt-connect/releases">Github Releases&lt;/a> 下载可执行文件&lt;/p>
&lt;h3 id="mac">Mac&lt;/h3>
&lt;p>安装sshuttle&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">brew install sshuttle
&lt;/code>&lt;/pre>&lt;/div>&lt;p>下载并安装KT&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ curl -OL https://rdc-incubators.oss-cn-beijing.aliyuncs.com/stable/ktctl_darwin_amd64.tar.gz
$ tar -xzvf ktctl_darwin_amd64.tar.gz
$ mv ktctl_darwin_amd64 /usr/local/bin/ktctl
$ ktctl -h
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="linux">Linux&lt;/h3>
&lt;p>安装sshuttle&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">pip install sshuttle
&lt;/code>&lt;/pre>&lt;/div>&lt;p>下载并安装KT&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ curl -OL https://rdc-incubators.oss-cn-beijing.aliyuncs.com/stable/ktctl_linux_amd64.tar.gz
$ tar -xzvf ktctl_linux_amd64.tar.gz
$ mv ktctl_linux_amd64 /usr/local/bin/ktctl
$ ktctl -h
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="windows">Windows&lt;/h3>
&lt;p>下载并解压可执行文件，并确保ktctl在PATH路径下&lt;/p>
&lt;h2 id="本地连接集群">本地连接集群&lt;/h2>
&lt;div class="alert alert-primary" role="alert">
以MacOS为例
&lt;/div>
&lt;p>使用 &lt;code>ktctl connect&lt;/code> 命令，启动的时候需要 admin 权限，需要输入密码&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ ktctl --namespace=default connect
1:51PM INF Connect Start At &lt;span style="color:#3677a9">69444&lt;/span>
1:51PM INF Client address 192.168.7.121
1:51PM INF deploy shadow deployment kt-connect-daemon-rcacy in namespace default
1:51PM INF pod label: &lt;span style="color:#40ffff">kt&lt;/span>=kt-connect-daemon-rcacy
1:51PM INF pod: kt-connect-daemon-rcacy-fd4c587f-zmn4z is running,but not ready
1:51PM INF pod: kt-connect-daemon-rcacy-fd4c587f-zmn4z is running,but not ready
1:51PM INF Shadow pod: kt-connect-daemon-rcacy-fd4c587f-zmn4z is ready.
Forwarding from 127.0.0.1:2222 -&amp;gt; &lt;span style="color:#3677a9">22&lt;/span>
Forwarding from [::1]:2222 -&amp;gt; &lt;span style="color:#3677a9">22&lt;/span>
1:51PM INF port-forward start at pid: &lt;span style="color:#3677a9">69445&lt;/span>
[&lt;span style="color:#24909d">local&lt;/span> sudo] Password: 1:51PM INF vpn(sshuttle) start at pid: &lt;span style="color:#3677a9">69449&lt;/span>
1:51PM INF KT proxy start successful
&lt;span style="color:#999;font-style:italic"># 这里需要输入密码&lt;/span>
Handling connection &lt;span style="color:#6ab825;font-weight:bold">for&lt;/span> &lt;span style="color:#3677a9">2222&lt;/span>
Warning: Permanently added &lt;span style="color:#ed9d13">&amp;#39;[127.0.0.1]:2222&amp;#39;&lt;/span> (ECDSA) to the list of known hosts.
bash: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)
client: Connected.
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里可以看到在 &lt;code>namespace:default&lt;/code> 中部署了一个 &lt;code>kt-connect-daemon-*&lt;/code> 的 &lt;code>Deployment&lt;/code>，如果这个 &lt;code>Deployment&lt;/code> 启动正常，就可以直接在本地访问 Kubernetes 集群内的服务了。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ kubectl get deploy | grep kt
kt-connect-daemon-rcacy 1/1 &lt;span style="color:#3677a9">1&lt;/span> &lt;span style="color:#3677a9">1&lt;/span> 5m35s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>访问集群服务，可以使用 &lt;code>curl&lt;/code> 或者直接在浏览器访问。（这里使用之前文章&lt;a href="../feiyan-grafana">《使用 Grafana 展示肺炎疫情动态》&lt;/a>中部署的服务）&lt;/p>
&lt;h3 id="使用-curl">使用 &lt;code>curl&lt;/code>&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ curl kk-feiyan
UP
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="直接使用浏览器">直接使用浏览器&lt;/h3>
&lt;p>&lt;img src="https://tvax3.sinaimg.cn/large/ad5fbf65ly1gd4zc1ddfij20fq03zglp.jpg" alt="image">&lt;/p>
&lt;h2 id="转发集群流量到本地">转发集群流量到本地&lt;/h2>
&lt;p>使用 &lt;code>ktctl exchange&lt;/code> 命令，这个命令的前提条件是 Kubernetes 集群中必须有已经已经存在的 &lt;code>Deployment&lt;/code>，在运行该命令时，将会起一个 shadow 容器，来代替已存在的 Deployment，调用该容器的流量，都会被转发到本地的指定端口。&lt;/p>
&lt;div class="alert alert-primary" role="alert">
要注意的是：该命令会将其代替的 Deployment 的 replicas 设置为0，可能会导致业务的暂停，请勿在生产环境中使用！
&lt;/div>
&lt;p>本地启动一个服务&lt;/p>
&lt;p>&lt;img src="https://tvax4.sinaimg.cn/large/ad5fbf65ly1gd4zsl7r14j20eq03r76o.jpg" alt="image">&lt;/p>
&lt;p>运行命令&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ ktctl exchange kk-feiyan --expose &lt;span style="color:#3677a9">8088&lt;/span>
2:13PM INF &lt;span style="color:#ed9d13">&amp;#39;KT Connect&amp;#39;&lt;/span> is runing, you can access &lt;span style="color:#24909d">local&lt;/span> app from cluster and localhost
2:13PM INF Client address 192.168.7.121
2:13PM INF deploy shadow deployment kk-feiyan-kt-yssnq in namespace default
2:13PM INF pod label: &lt;span style="color:#40ffff">kt&lt;/span>=kk-feiyan-kt-yssnq
2:13PM INF pod: kk-feiyan-kt-yssnq-6464bbf74d-smvhc is running,but not ready
2:13PM INF pod: kk-feiyan-kt-yssnq-6464bbf74d-smvhc is running,but not ready
2:13PM INF Shadow pod: kk-feiyan-kt-yssnq-6464bbf74d-smvhc is ready.
2:13PM INF create exchange shadow kk-feiyan-kt-yssnq in namespace default
2:13PM INF scale deployment kk-feiyan to &lt;span style="color:#3677a9">0&lt;/span>
2:13PM INF * kk-feiyan (&lt;span style="color:#3677a9">0&lt;/span> replicas) success
2:13PM INF remote 172.22.1.166 forward to &lt;span style="color:#24909d">local&lt;/span> &lt;span style="color:#3677a9">8088&lt;/span>
Forwarding from 127.0.0.1:2266 -&amp;gt; &lt;span style="color:#3677a9">22&lt;/span>
Forwarding from [::1]:2266 -&amp;gt; &lt;span style="color:#3677a9">22&lt;/span>
2:13PM INF exchange port forward to &lt;span style="color:#24909d">local&lt;/span> start at pid: &lt;span style="color:#3677a9">70269&lt;/span>
2:13PM INF redirect request from pod 172.22.1.166 &lt;span style="color:#3677a9">22&lt;/span> to 127.0.0.1:2266 starting
Handling connection &lt;span style="color:#6ab825;font-weight:bold">for&lt;/span> &lt;span style="color:#3677a9">2266&lt;/span>
Warning: Permanently added &lt;span style="color:#ed9d13">&amp;#39;[127.0.0.1]:2266&amp;#39;&lt;/span> (ECDSA) to the list of known hosts.
bash: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)
2:13PM INF ssh remote port-forward start at pid: &lt;span style="color:#3677a9">70270&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看 Deployment&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ kubectl get deploy | grep kk-feiyan
kk-feiyan 0/0 &lt;span style="color:#3677a9">0&lt;/span> &lt;span style="color:#3677a9">0&lt;/span> 39d &lt;span style="color:#999;font-style:italic"># 原服务&lt;/span>
kk-feiyan-kt-eclcc 1/1 &lt;span style="color:#3677a9">1&lt;/span> &lt;span style="color:#3677a9">1&lt;/span> 89s &lt;span style="color:#999;font-style:italic"># 转发流量服务&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样的话，集群内调用 &lt;code>kk-feiyan&lt;/code> 这个服务的流量都会被转发到本地&lt;/p>
&lt;p>&lt;strong>集群内调用：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ curl kk-feiyan
UP
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>可以看到流量被抓发到了本地&lt;/strong>
&lt;img src="https://tvax3.sinaimg.cn/large/ad5fbf65ly1gd4zuym6ofj20eq052n0d.jpg" alt="image">&lt;/p>
&lt;h2 id="将本地服务暴露到-kubernetes-集群">将本地服务暴露到 Kubernetes 集群&lt;/h2>
&lt;p>有些时候，我们并不想使用 &lt;code>exchange&lt;/code> 来代替已经存在的 Deployment，只想在集群内新建一个服务来将流量转发到本，以完成调试。&lt;/p>
&lt;p>这个时候使用 &lt;code>ktctl run&lt;/code>，就可以满足需求，该命令会在 Kubernetes 集群中新建一个服务，并将访问该服务的流量被转发到本地的指定端口。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ ktctl run localservice --port &lt;span style="color:#3677a9">8088&lt;/span> --expose
2:33PM INF Client address 192.168.7.121
2:33PM INF deploy shadow deployment localservice in namespace default
2:33PM INF pod label: &lt;span style="color:#40ffff">kt&lt;/span>=localservice
2:33PM INF pod: localservice-77d565c488-64hpp is running,but not ready
2:33PM INF pod: localservice-77d565c488-64hpp is running,but not ready
2:33PM INF Shadow pod: localservice-77d565c488-64hpp is ready.
2:33PM INF create shadow pod localservice-77d565c488-64hpp ip 172.22.1.74
2:33PM INF expose deployment localservice to localservice:8088
2:33PM INF remote 172.22.1.74 forward to &lt;span style="color:#24909d">local&lt;/span> &lt;span style="color:#3677a9">8088&lt;/span>
Forwarding from 127.0.0.1:2274 -&amp;gt; &lt;span style="color:#3677a9">22&lt;/span>
Forwarding from [::1]:2274 -&amp;gt; &lt;span style="color:#3677a9">22&lt;/span>
2:33PM INF exchange port forward to &lt;span style="color:#24909d">local&lt;/span> start at pid: &lt;span style="color:#3677a9">70899&lt;/span>
2:33PM INF redirect request from pod 172.22.1.74 &lt;span style="color:#3677a9">22&lt;/span> to 127.0.0.1:2274 starting
Handling connection &lt;span style="color:#6ab825;font-weight:bold">for&lt;/span> &lt;span style="color:#3677a9">2274&lt;/span>
Warning: Permanently added &lt;span style="color:#ed9d13">&amp;#39;[127.0.0.1]:2274&amp;#39;&lt;/span> (ECDSA) to the list of known hosts.
bash: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)
2:33PM INF ssh remote port-forward start at pid: &lt;span style="color:#3677a9">70903&lt;/span>
2:33PM INF forward remote 172.22.1.74:8088 -&amp;gt; 127.0.0.1:8088
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到该服务已经被拉起了&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ kubectl get deploy localservice
NAME READY UP-TO-DATE AVAILABLE AGE
localservice 1/1 &lt;span style="color:#3677a9">1&lt;/span> &lt;span style="color:#3677a9">1&lt;/span> 86s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>访问该服务&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ curl localservice:8088
UP
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到流量被转发到了本地
&lt;img src="https://tva3.sinaimg.cn/large/ad5fbf65ly1gd50e6lkquj20ff05z782.jpg" alt="image">&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本地访问 k8s 内网，将 k8s 流量转发到本地，靠着这两大功能 &lt;code>Kt Connect&lt;/code> 可以称之为研发侧的利器，我们可以轻松的在本地调用集群服务，或者让集群调用本地的服务，这就让开发/测试 k8s 集群中发起调用的服务，在本地断点 debug 成为了现实，非常好用。同时还有其他一些没有介绍的功能，比如：&lt;/p>
&lt;ul>
&lt;li>Service Mesh 支持，可以支持用户可以基于Service Mesh的能力做更多自定义的流量规则定义&lt;/li>
&lt;li>Dashboard 功能，管理所以使用 kt 连入集群的用户等等&lt;/li>
&lt;/ul>
&lt;p>值得一提的是，&lt;code>ktctl run&lt;/code> 功能是我提出该场景并希望能实现，该 &lt;a href="https://github.com/alibaba/kt-connect/issues/89">issue&lt;/a> 提出仅一天就通过并完成了开发。给高效的开发人员点赞。&lt;/p></description></item><item><title>Post: 修改 Nginx Ingress 日志打印格式</title><link>https://guoxudong.io/post/nginx-ingress-log-aliyun/</link><pubDate>Mon, 02 Mar 2020 15:29:16 +0800</pubDate><guid>https://guoxudong.io/post/nginx-ingress-log-aliyun/</guid><description>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>最近接到一个需求，需要展示 ingress 上面的访问日志，由于我们的业务系统都部署在 Kubernetes 上面，通过 ingress 进行访问，所以这里的访问日志，其实就是我们全部业务系统的访问日志。&lt;/p>
&lt;p>日志采集方面，阿里云天生就提供了 nginx-ingress 日志和采集和展示，本身提供很多不错的基于 ingress 日志数据的图表与分析。如果你使用的是阿里云 ACK 容器服务，那么极端推荐使用，配置方法见官方文档：https://help.aliyun.com/document_detail/86532.html。&lt;/p>
&lt;p>&lt;img src="https://tva2.sinaimg.cn/large/ad5fbf65gy1gcfmo5d410j21970nzwjg.jpg" alt="image">&lt;/p>
&lt;p>让人头秃的是，我们这次不但要采集 ingress 日志上比较常规的 &lt;code>url&lt;/code> &lt;code>client_ip&lt;/code> &lt;code>method&lt;/code> &lt;code>status&lt;/code> 等字段，还要采集我们系统在 &lt;code>Request Headers&lt;/code> 里面自定义的参数，这些参数是默认的 ingress 并不展示的，所以需要我们进行调整。&lt;/p>
&lt;h2 id="开始">开始&lt;/h2>
&lt;p>首先明确需要调整的组件：&lt;/p>
&lt;ul>
&lt;li>&lt;code>nginx-ingress&lt;/code> 的 ConfigMap：用于打印自定义日志字段&lt;/li>
&lt;li>&lt;code>AliyunLogConfig&lt;/code>：这个是阿里云日志服务的 CRD 扩展，需要在这个里面加入新增的字段名和修改后的正则表达式&lt;/li>
&lt;li>在日志服务控制台，添加新增字段的指定字段查询&lt;/li>
&lt;li>新增展示仪表盘&lt;/li>
&lt;/ul>
&lt;h3 id="调整-ingress-日志输出">调整 ingress 日志输出&lt;/h3>
&lt;p>我们 ingress 组件使用的是 &lt;code>nginx-ingress-container&lt;/code>，这里要调整日志输出格式，老规矩，直接官方文档：https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/。&lt;/p>
&lt;p>从文档可见，只需要调整 &lt;code>ingress-nginx&lt;/code> 的 ConfigMap &lt;code>nginx-configuration&lt;/code> data 中的 &lt;code>log-format-upstream&lt;/code> 字段即可。&lt;/p>
&lt;div class="alert alert-primary" role="alert">
&lt;p>知识点：&lt;/p>
&lt;p>官方文档里面给的说明不是很详细，没有提到 &lt;code>Request Headers&lt;/code> 里自定义的字段应该怎么表示（也有可能是我眼瘸没看见），但经过我多次试验发现，&lt;code>Request Headers&lt;/code> 里的字段在 &lt;code>log-format-upstream&lt;/code> 中应该使用 &lt;code>$http_{your field}&lt;/code> 表示，比如 &lt;code>$http_cookie&lt;/code>；而带 &lt;code>-&lt;/code> 的字段则需要将 &lt;code>-&lt;/code> 改为 &lt;code>_&lt;/code>，并且使用小写，比如 &lt;code>app-Id&lt;/code> 就应使用 &lt;code>$http_app_id&lt;/code> 表示。&lt;/p>
&lt;/div>
&lt;p>修改 ConfigMap，&lt;code>ingress-controller&lt;/code> 将进行热更新，看到如下日志，就证明配置已完成更新，接下来就可以看到你自定义字段的值已经打印出来了。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">I0302 &lt;span style="color:#3677a9">08&lt;/span>:&lt;span style="color:#3677a9">20&lt;/span>:&lt;span style="color:#3677a9">58.393365&lt;/span> &lt;span style="color:#3677a9">9&lt;/span> controller.&lt;span style="color:#6ab825;font-weight:bold">go&lt;/span>:&lt;span style="color:#3677a9">200&lt;/span>] Backend successfully reloaded.
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="调整阿里云日志组件配置">调整阿里云日志组件配置&lt;/h3>
&lt;div class="alert alert-primary" role="alert">
执行下面的步骤请确保已经按照&lt;a href="https://help.aliyun.com/document_detail/86532.html">官方文档&lt;/a>正确部署阿里云日志服务在您的 K8S 集群之后，并且已达到要求的版本。
&lt;/div>
&lt;p>日志已经成功打印了，接下来就是调整日志采集的字段了，这里只需要调整日志服务 CRD 的扩展配置即可。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ kubectl edit AliyunLogConfig k8s-nginx-ingress
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在修改配置之前，推荐先去 &lt;a href="https://regex101.com/">https://regex101.com/&lt;/a> 验证正则表达式是否正确，将调整过的正则表达式和 &lt;code>ingress-controller&lt;/code> 打印的日志贴入下图指定位置，就可以看出正则表达式是否正确。&lt;/p>
&lt;p>&lt;img src="https://tvax1.sinaimg.cn/large/ad5fbf65gy1gcfo9lxuc6j21gv0juwka.jpg" alt="image">&lt;/p>
&lt;p>然后将添加的字段名称（这个名称将作为 key 在日志服务中展示，可以与 header 中的字段不同）和正则表达式贴入如下 CRD 中。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#6ab825;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#666"> &lt;/span>log.alibabacloud.com/v1alpha1&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">kind&lt;/span>:&lt;span style="color:#666"> &lt;/span>AliyunLogConfig&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># your config name, must be unique in you k8s cluster&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>k8s-nginx-ingress&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">spec&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># logstore name to upload log&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">logstore&lt;/span>:&lt;span style="color:#666"> &lt;/span>nginx-ingress&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># product code, only for k8s nginx ingress&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">productCode&lt;/span>:&lt;span style="color:#666"> &lt;/span>k8s-nginx-ingress&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># logtail config detail&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">logtailConfig&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">inputType&lt;/span>:&lt;span style="color:#666"> &lt;/span>plugin&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># logtail config name, should be same with [metadata.name]&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">configName&lt;/span>:&lt;span style="color:#666"> &lt;/span>k8s-nginx-ingress&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">inputDetail&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">plugin&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">inputs&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">type&lt;/span>:&lt;span style="color:#666"> &lt;/span>service_docker_stdout&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">detail&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">IncludeLabel&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">io.kubernetes.container.name&lt;/span>:&lt;span style="color:#666"> &lt;/span>nginx-ingress-controller&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">Stderr&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">false&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">Stdout&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">true&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">processors&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">type&lt;/span>:&lt;span style="color:#666"> &lt;/span>processor_regex&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">detail&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">KeepSource&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">false&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">Keys&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- client_ip&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- x_forward_for&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- remote_user&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- time&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- method&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- url&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- version&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- status&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- body_bytes_sent&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- http_referer&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- http_user_agent&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- request_length&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- request_time&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- proxy_upstream_name&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- upstream_addr&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- upstream_response_length&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- upstream_response_time&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- upstream_status&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- req_id&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- host&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#999;font-style:italic">#需要添加的字段名称&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- ...&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">NoKeyError&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">true&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">NoMatchError&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">true&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">Regex&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic">#修改后的正则表达式&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">SourceKey&lt;/span>:&lt;span style="color:#666"> &lt;/span>content&lt;span style="color:#666">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="日志控制台新增字段">日志控制台新增字段&lt;/h3>
&lt;p>如果上面的操作无误的话，日志服务中就会展示您添加的字段了，如果配置有误，所有的自定义字段都会不显示，只会显示保留字段名称。&lt;/p>
&lt;p>添加指定字段查询，就可以快速查看添加的字段了。&lt;/p>
&lt;p>&lt;img src="https://tva3.sinaimg.cn/large/ad5fbf65gy1gcfohy9fv4j21460gxtc6.jpg" alt="image">&lt;/p>
&lt;h3 id="新增展示仪表盘">新增展示仪表盘&lt;/h3>
&lt;p>日志既然已经取到了，那么展示就很容易了，直接在查询栏中输入分析语句，日志服务支持 SQL 聚合日志，并直接生成统计图表，点击添加到仪表盘可以就可以添加到现有仪表盘或者新建一个仪表盘。&lt;/p>
&lt;p>&lt;img src="https://tva2.sinaimg.cn/large/ad5fbf65gy1gcfos33c23j219a0nuae3.jpg" alt="image">&lt;/p>
&lt;h2 id="成果">成果&lt;/h2>
&lt;p>之后进行一些微调，添加过滤栏，由于这里统计的是登录用户，你甚至都可以添加一个词云来看看哪些用于使用系统比较频繁。当然，想添加什么都看您的喜好，日志在你手里，想怎么分析都可以。&lt;/p>
&lt;p>&lt;img src="https://tva4.sinaimg.cn/large/ad5fbf65gy1gcfowk10tjj21970ns79i.jpg" alt="image">&lt;/p>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>本次实现的功能并不是什么高深的功能，只不过是一个简单的访问日志记录和展示，相信每个系统其实都有一套这种功能。但是这种实现方式在我看来优点更多：&lt;/p>
&lt;ul>
&lt;li>无代码：全程没有写一行代码，如果有的话，也就是业务需要统一 &lt;code>Request Headers&lt;/code> 里面的字段。&lt;/li>
&lt;li>配置简单：只需要修改 nginx ConfigMap 中的一个字段，并在 CRD 中添加字段名称和正在表达式，唯一的难度可能就是正则表达式。&lt;/li>
&lt;li>配置快：整体的配置时间很短，加上查文档和调整图表也不过半天的时间，肯定比 &lt;code>提需求-评估-开发-测试-验收&lt;/code> 全流程走一遍，前端后端撕一遍要快的多的多的多。&lt;/li>
&lt;li>高度定制：可以根据自己的喜好，随意定制图表。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>最近发现阿里云日志服务是一个宝藏产品，从安全到 k8s 业务，从成本控制到疫情动态，日志服务真的就是把所有没有前端开发资源的服务都帮了一把。
&amp;mdash; 摘自本人朋友圈&lt;/p>
&lt;/blockquote></description></item><item><title>Post: Kubecm：管理你的 kubeconfig</title><link>https://guoxudong.io/post/kubecm/</link><pubDate>Mon, 09 Dec 2019 10:07:46 +0800</pubDate><guid>https://guoxudong.io/post/kubecm/</guid><description>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>该项目脱胎于 &lt;a href="https://github.com/sunny0826/mergeKubeConfig">mergeKubeConfig&lt;/a> 项目，最早写该项目的目的是在一堆杂乱无章的 kubeconfig 中自由的切换。随着需要操作的 Kubernetes 集群越来越多，在不同的集群之间切换也越来越麻烦，而操作 Kubernetes 集群的本质不过是通过 &lt;code>kubeconfig&lt;/code> 访问 Kubernetes 集群的 API Server，以操作 Kubernetes 的各种资源，而 &lt;code>kubeconfig&lt;/code> 不过是一个 yaml 文件，用来保存访问集群的密钥，最早的 &lt;a href="https://github.com/sunny0826/mergeKubeConfig">mergeKubeConfig&lt;/a> 不过是一个操作 yaml 文件的 Python 脚本。而随着 golang 学习的深入，也就动了重写这个项目的念头，就这样 &lt;a href="https://github.com/sunny0826/kubecm">kubecm&lt;/a> 诞生了。&lt;/p>
&lt;h2 id="kubecm">kubecm&lt;/h2>
&lt;p>&lt;a href="https://github.com/sunny0826/kubecm">kubecm&lt;/a> 由 golang 编写，支持 &lt;code>Mac&lt;/code> &lt;code>Linux&lt;/code> 和 &lt;code>windows&lt;/code> 平台，&lt;code>delete&lt;/code> &lt;code>rename&lt;/code> &lt;code>switch&lt;/code> 提供比较实用的交互式的操作，目前的功能包括：&lt;/p>
&lt;ul>
&lt;li>add ：添加新的 &lt;code>kubeconfig&lt;/code> 到 &lt;code>$HOME/.kube/config&lt;/code> 中&lt;/li>
&lt;li>completion ：命令行自动补全功能&lt;/li>
&lt;li>delete：删除已有的 &lt;code>context&lt;/code> ，提供交互式和指定删除两种方式&lt;/li>
&lt;li>merge：将指定目录中的 &lt;code>kubeconfig&lt;/code> 合并为一个 &lt;code>kubeconfig&lt;/code> 文件&lt;/li>
&lt;li>rename：重名指定的 &lt;code>context&lt;/code>，提供交互式和指定重命名两种方式&lt;/li>
&lt;li>switch：交互式切换 &lt;code>context&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="安装">安装&lt;/h2>
&lt;p>&lt;a href="https://github.com/sunny0826/kubecm">kubecm&lt;/a> 支持 &lt;code>Mac&lt;/code> &lt;code>Linux&lt;/code> 和 &lt;code>windows&lt;/code> 平台，安装方式也比较简单：&lt;/p>
&lt;h4 id="macos">MacOS&lt;/h4>
&lt;div class="alert alert-primary" role="alert">
使用 &lt;code>brew&lt;/code> 或者直接下载二进制可执行文件
&lt;/div>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">brew install sunny0826/tap/kubecm
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="linux">Linux&lt;/h4>
&lt;div class="alert alert-primary" role="alert">
下载二进制可执行文件
&lt;/div>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#999;font-style:italic"># linux x86_64&lt;/span>
curl -Lo kubecm.tar.gz https://github.com/sunny0826/kubecm/releases/download/v&lt;span style="color:#ed9d13">${&lt;/span>&lt;span style="color:#40ffff">VERSION&lt;/span>&lt;span style="color:#ed9d13">}&lt;/span>/kubecm_&lt;span style="color:#ed9d13">${&lt;/span>&lt;span style="color:#40ffff">VERSION&lt;/span>&lt;span style="color:#ed9d13">}&lt;/span>_Linux_x86_64.tar.gz
tar -zxvf kubecm.tar.gz kubecm
&lt;span style="color:#24909d">cd&lt;/span> kubecm
sudo mv kubecm /usr/local/bin/
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="windows">Windows&lt;/h4>
&lt;div class="alert alert-primary" role="alert">
下载二进制可执行文件，并将文件移动到 &lt;code>$PATH&lt;/code> 中即可
&lt;/div>
&lt;h2 id="命令行自动补全">命令行自动补全&lt;/h2>
&lt;div class="alert alert-primary" role="alert">
&lt;a href="https://github.com/sunny0826/kubecm">kubecm&lt;/a> 提供了和 &lt;a href="https://github.com/kubernetes/kubectl">kubectl&lt;/a> 一样的 completion 命令行自动补全功能（支持 bash/zsh）
&lt;/div>
&lt;p>以 &lt;code>zsh&lt;/code> 为例，在 &lt;code>$HOME/.zshrc&lt;/code> 中添加&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-vim" data-lang="vim">source &amp;lt;(kubecm completion zsh)&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后使用 &lt;code>source&lt;/code> 命令，使其生效&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-zsh" data-lang="zsh">&lt;span style="color:#24909d">source&lt;/span> &lt;span style="color:#40ffff">$HOME&lt;/span>/.zshrc
&lt;/code>&lt;/pre>&lt;/div>&lt;p>之后，在输入 &lt;code>kubecm&lt;/code> 后按 &lt;kbd>tab&lt;/kbd> 键，就可以看到命令行自动补全的内容&lt;/p>
&lt;p>&lt;img src="https://tva2.sinaimg.cn/large/ad5fbf65gy1g9qa0yy3bvj21co0f2hdt.jpg" alt="image">&lt;/p>
&lt;h2 id="操作-kubeconfig">操作 kubeconfig&lt;/h2>
&lt;div class="alert alert-primary" role="alert">
&lt;a href="https://github.com/sunny0826/kubecm">kubecm&lt;/a> 可以实现 &lt;code>kubeconfig&lt;/code> 的查看、添加、删除、合并、重命名和切换
&lt;/div>
&lt;h4 id="查看">查看&lt;/h4>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#999;font-style:italic"># 查看 $HOME/.kube/config 中所有的 context&lt;/span>
kubecm
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="添加">添加&lt;/h4>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#999;font-style:italic"># 添加 example.yaml 到 $HOME/.kube/config.yaml，该方式不会覆盖源 kubeconfig，只会在当前目录中生成一个 config.yaml 文件&lt;/span>
kubecm add -f example.yaml
&lt;span style="color:#999;font-style:italic"># 功能同上，但是会将 example.yaml 中的 context 命名为 test&lt;/span>
kubecm add -f example.yaml -n &lt;span style="color:#24909d">test&lt;/span>
&lt;span style="color:#999;font-style:italic"># 添加 -c 会覆盖源 kubeconfig&lt;/span>
kubecm add -f example.yaml -c
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="删除">删除&lt;/h4>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#999;font-style:italic"># 交互式删除&lt;/span>
kubecm delete
&lt;span style="color:#999;font-style:italic"># 删除指定 context&lt;/span>
kubecm delete my-context
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="合并">合并&lt;/h4>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#999;font-style:italic"># 合并 test 目录中的 kubeconfig,该方式不会覆盖源 kubeconfig，只会在当前目录中生成一个 config.yaml 文件&lt;/span>
kubecm merge -f &lt;span style="color:#24909d">test&lt;/span>
&lt;span style="color:#999;font-style:italic"># 添加 -c 会覆盖源 kubeconfig&lt;/span>
kubecm merge -f &lt;span style="color:#24909d">test&lt;/span> -c
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="重命名">重命名&lt;/h4>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#999;font-style:italic"># 交互式重命名&lt;/span>
kubecm rename
&lt;span style="color:#999;font-style:italic"># 将 dev 重命名为 test&lt;/span>
kubecm rename -o dev -n &lt;span style="color:#24909d">test&lt;/span>
&lt;span style="color:#999;font-style:italic"># 重命名 current-context 为 dev&lt;/span>
kubecm rename -n dev -c
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="切换默认-namespace">切换默认 namespace&lt;/h4>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#999;font-style:italic"># 交互式切换 namespace&lt;/span>
kubecm namespace
&lt;span style="color:#999;font-style:italic"># 或者&lt;/span>
kubecm ns
&lt;span style="color:#999;font-style:italic"># 切换默认 namespace 为 kube-system&lt;/span>
kubecm ns kube-system
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="效果展示">效果展示&lt;/h2>
&lt;p>&lt;img src="Interaction.gif" alt="">&lt;/p>
&lt;h2 id="视频介绍">视频介绍&lt;/h2>
&lt;div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
&lt;iframe src="//player.bilibili.com/player.html?aid=88259938&amp;amp;cid=150776221&amp;amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> &lt;/iframe>
&lt;/div>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>&lt;a href="https://github.com/sunny0826/kubecm">kubecm&lt;/a> 项目的初衷为学习 golang 并熟悉 client-go 的使用，随着使用的深入，断断续续增加了不少功能，开发出了一个看上去还算正规的项目。总的来说都是根据自己的喜好来开发的业余项目，欢迎各位通过 &lt;a href="https://github.com/sunny0826/kubecm/issues/new">ISSUE&lt;/a> 来进行交流和讨论。&lt;/p></description></item><item><title>Post: 小工具介绍：KubeWatch</title><link>https://guoxudong.io/post/kubewatch/</link><pubDate>Wed, 04 Dec 2019 17:09:51 +0800</pubDate><guid>https://guoxudong.io/post/kubewatch/</guid><description>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>这次要介绍一个 Kubernetes 资源观测工具，实时监控 Kubernetes 集群中各种资源的新建、更新和删除，并实时通知到各种协作软件/聊天软件，目前支持的通知渠道有：&lt;/p>
&lt;ul>
&lt;li>&lt;code>slack&lt;/code>&lt;/li>
&lt;li>&lt;code>hipchat&lt;/code>&lt;/li>
&lt;li>&lt;code>mattermost&lt;/code>&lt;/li>
&lt;li>&lt;code>flock&lt;/code>&lt;/li>
&lt;li>&lt;code>webhook&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>我这边开发了钉钉的通知渠道，但是在上游 &lt;a href="https://github.com/bitnami-labs/kubewatch/issues/198">ISSUE#198&lt;/a> 中提出的贡献请求并没有得到回应，所以这边只能 fork 了代码，然后自己进行了开发，以支持钉钉通知。&lt;/p>
&lt;h2 id="安装">安装&lt;/h2>
&lt;p>这里推荐使用 helm 进行安装，快速部署&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">helm install kubewatch stable/kubewatch &lt;span style="color:#ed9d13">\
&lt;/span>&lt;span style="color:#ed9d13">&lt;/span>--set rbac.create=&lt;span style="color:#24909d">true&lt;/span> &lt;span style="color:#ed9d13">\
&lt;/span>&lt;span style="color:#ed9d13">&lt;/span>--set slack.channel=&lt;span style="color:#ed9d13">&amp;#39;#YOUR_CHANNEL&amp;#39;&lt;/span> &lt;span style="color:#ed9d13">\
&lt;/span>&lt;span style="color:#ed9d13">&lt;/span>--set slack.token=&lt;span style="color:#ed9d13">&amp;#39;xoxb-YOUR_TOKEN&amp;#39;&lt;/span> &lt;span style="color:#ed9d13">\
&lt;/span>&lt;span style="color:#ed9d13">&lt;/span>--set resourcesToWatch.pod=&lt;span style="color:#24909d">true&lt;/span> &lt;span style="color:#ed9d13">\
&lt;/span>&lt;span style="color:#ed9d13">&lt;/span>--set resourcesToWatch.daemonset=&lt;span style="color:#24909d">true&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果想使用钉钉通知，则可以在 &lt;a href="https://github.com/sunny0826/kubewatch-chat">GitHub&lt;/a> 上拉取我的代码，代码中包含 helm chart 包，可直接进行安装&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">git clone https://github.com/sunny0826/kubewatch-chat.git
&lt;span style="color:#24909d">cd&lt;/span> kubewatch-chat
helm install kubewatch kubewatch &lt;span style="color:#ed9d13">\
&lt;/span>&lt;span style="color:#ed9d13">&lt;/span>--set dingtalk.sign=&lt;span style="color:#ed9d13">&amp;#34;XXX&amp;#34;&lt;/span> &lt;span style="color:#ed9d13">\
&lt;/span>&lt;span style="color:#ed9d13">&lt;/span>--set dingtalk.token=&lt;span style="color:#ed9d13">&amp;#34;XXXX-XXXX-XXXX&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="钉钉配置">钉钉配置&lt;/h2>
&lt;p>在钉钉中创建 &lt;code>智能群助手&lt;/code> ，之后&lt;/p>
&lt;h3 id="获取-token">获取 token&lt;/h3>
&lt;p>复制的 webhook 中 &lt;code>https://oapi.dingtalk.com/robot/send?access_token={YOUR_TOKEN}&lt;/code>, &lt;code>{YOUR_TOKEN}&lt;/code> 就是要填入的 token。&lt;/p>
&lt;p>&lt;img src="https://tva4.sinaimg.cn/large/ad5fbf65gy1g9ku2hvs16j20ep05smxk.jpg" alt="">&lt;/p>
&lt;h2 id="安全设置">安全设置&lt;/h2>
&lt;p>钉钉智能群助手在更新后新增了安全设置，提供三种验证方式 &lt;code>自定义关键词&lt;/code> &lt;code>加签&lt;/code> &lt;code>IP地址（段）&lt;/code>，这里推荐使用 &lt;code>IP地址（段）的方式&lt;/code>，直接将 Kubernetes 集群的出口 IP 填入设置即可。同时也提供了 &lt;code>加签&lt;/code> 的方式，拷贝秘钥，将其填入 &lt;code>dingtalk.sign&lt;/code> 中。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/ad5fbf65gy1g9ku6qjwy2j20fo077glw.jpg" alt="">&lt;/p>
&lt;h2 id="项目配置">项目配置&lt;/h2>
&lt;p>编辑 &lt;code>kubewatch/value.yaml&lt;/code> ，修改配置&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#999;font-style:italic">## Global Docker image parameters&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic">## Please, note that this will override the image parameters, including dependencies, configured to use the global value&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic">## Current available global Docker image parameters: imageRegistry and imagePullSecrets&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic">##&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># global:&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># imageRegistry: myRegistryName&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># imagePullSecrets:&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># - myRegistryKeySecretName&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">slack&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">enabled&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">false&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">channel&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#ed9d13">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">token&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#ed9d13">&amp;#34;xoxb&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">hipchat&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">enabled&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">false&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># room: &amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># token: &amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># url: &amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">mattermost&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">enabled&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">false&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># channel: &amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># url: &amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># username: &amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">flock&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">enabled&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">false&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># url: &amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">webhook&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">enabled&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">false&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># url: &amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">dingtalk&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">enabled&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">true&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">token&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#ed9d13">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">sign&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#ed9d13">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># namespace to watch, leave it empty for watching all.&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">namespaceToWatch&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#ed9d13">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># Resources to watch&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">resourcesToWatch&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">deployment&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">true&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">replicationcontroller&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">false&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">replicaset&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">false&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">daemonset&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">false&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">services&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">false&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">pod&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">true&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">job&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">false&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">persistentvolume&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">false&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">image&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">registry&lt;/span>:&lt;span style="color:#666"> &lt;/span>docker.io&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># repository: bitnami/kubewatch&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">repository&lt;/span>:&lt;span style="color:#666"> &lt;/span>guoxudongdocker/kubewatch-chart&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># tag: 0.0.4-debian-9-r405&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">tag&lt;/span>:&lt;span style="color:#666"> &lt;/span>latest&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">pullPolicy&lt;/span>:&lt;span style="color:#666"> &lt;/span>Always&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic">## Optionally specify an array of imagePullSecrets.&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic">## Secrets must be manually created in the namespace.&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic">## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic">##&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># pullSecrets:&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># - myRegistryKeySecretName&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic">## String to partially override kubewatch.fullname template (will maintain the release name)&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic">##&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># nameOverride:&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic">## String to fully override kubewatch.fullname template&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic">##&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># fullnameOverride:&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">rbac&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># If true, create &amp;amp; use RBAC resources&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic">#&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">create&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">true&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">serviceAccount&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># Specifies whether a ServiceAccount should be created&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">create&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">true&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># The name of the ServiceAccount to use.&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># If not set and create is true, a name is generated using the fullname template&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">resources&lt;/span>:&lt;span style="color:#666"> &lt;/span>{}&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># limits:&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># cpu: 100m&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># memory: 300Mi&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># requests:&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># cpu: 100m&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># memory: 300Mi&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># Affinity for pod assignment&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># affinity: {}&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># Tolerations for pod assignment&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># Ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">tolerations&lt;/span>:&lt;span style="color:#666"> &lt;/span>[]&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># Node labels for pod assignment&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># Ref: https://kubernetes.io/docs/user-guide/node-selection/&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">nodeSelector&lt;/span>:&lt;span style="color:#666"> &lt;/span>{}&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">podAnnotations&lt;/span>:&lt;span style="color:#666"> &lt;/span>{}&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">podLabels&lt;/span>:&lt;span style="color:#666"> &lt;/span>{}&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">replicaCount&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#3677a9">1&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 &lt;code>value.yaml&lt;/code> 安装&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">git clone https://github.com/sunny0826/kubewatch-chat.git
&lt;span style="color:#24909d">cd&lt;/span> kubewatch-chat
helm install my-release -f kubewatch/values.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="slack-配置">Slack 配置&lt;/h2>
&lt;p>Slack 为 kubewatch 默认的通知软件，这里就不简介 Slack 的安装和注册，直接从创建 APP 开始&lt;/p>
&lt;h3 id="创建一个-app">创建一个 APP&lt;/h3>
&lt;p>进去创建 &lt;a href="https://api.slack.com/apps">APP 页面&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/ad5fbf65gy1g9kum3x5npj21h40p6tdx.jpg" alt="image">&lt;/p>
&lt;p>选择 &lt;code>App Name&lt;/code> 和 &lt;code>Development Slack Workspace&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/ad5fbf65gy1g9kupp0av1j210c0uejvj.jpg" alt="">&lt;/p>
&lt;h3 id="添加-bot-用户">添加 Bot 用户&lt;/h3>
&lt;p>&lt;img src="https://tvax3.sinaimg.cn/large/ad5fbf65gy1g9kuszmgggj21n4156gu2.jpg" alt="image">&lt;/p>
&lt;h3 id="添加-app-到-workspace">添加 App 到 Workspace&lt;/h3>
&lt;p>&lt;img src="https://tva3.sinaimg.cn/large/ad5fbf65gy1g9kuyzwzetj21qu0wmq9n.jpg" alt="image">&lt;/p>
&lt;h3 id="获取-bot-token">获取 Bot-token&lt;/h3>
&lt;p>&lt;img src="https://tvax3.sinaimg.cn/large/ad5fbf65gy1g9kv06dva8j21s60uajxf.jpg" alt="image">&lt;/p>
&lt;h2 id="通知效果">通知效果&lt;/h2>
&lt;p>在 Slack 中，&lt;code>创建&lt;/code> &lt;code>更新&lt;/code> &lt;code>删除&lt;/code> 分别以绿、黄和红色代表&lt;/p>
&lt;p>&lt;img src="https://tvax1.sinaimg.cn/large/ad5fbf65gy1g9kv23nvmoj213c0mewj4.jpg" alt="image">&lt;/p>
&lt;p>在钉钉中，我进行了汉化&lt;/p>
&lt;p>&lt;img src="https://tvax3.sinaimg.cn/large/ad5fbf65gy1g9kv5fppglj20dd08zdgs.jpg" alt="image">&lt;/p>
&lt;p>&lt;img src="https://tvax4.sinaimg.cn/large/ad5fbf65gy1g9kv5uuxn4j20ea08fgmk.jpg" alt="image">&lt;/p>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>对于 kubewatch 我们这里主要用作监控各种 CronJob 的定时触发状态，已经 ConfigMap 和 Secrets 的状态变化，同时也观察 HPA 触发的弹性伸缩的状态，可以实时观测到业务高峰的到来，是一个不错的小工具。&lt;/p></description></item><item><title>Post: 使用 Velero 进行集群备份与迁移</title><link>https://guoxudong.io/post/aliyun-velero/</link><pubDate>Wed, 13 Nov 2019 09:13:22 +0800</pubDate><guid>https://guoxudong.io/post/aliyun-velero/</guid><description>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>在近日的一个风和日丽的下午，正在快乐的写 bug 时，突然间钉钉就被 call 爆了，原来是 k8s 测试集群的一个 namespace 突然不见了。这个 namespace 里面有 60 多个服务，瞬间全部没有了……虽然得益于我们的 CI/CD 系统，这些服务很快都重新部署并正常运行了，但是如果在生产环境，那后果就是不可想象的了。在排查这个问题发生的原因的同时，集群资源的灾备和恢复功能就提上日程了，这时 Velero 就出现了。&lt;/p>
&lt;h2 id="velero">Velero&lt;/h2>
&lt;p>&lt;a href="https://github.com/vmware-tanzu/velero">Velero&lt;/a> 是 VMWare 开源的 k8s 集群备份、迁移工具。可以帮助我们完成 k8s 的例行备份工作，以便在出现上面问题的时候可以快速进行恢复。同时也提供了集群迁移功能，可以将 k8s 资源迁移到其他 k8s 集群的功能。Velero 将集群资源保存在对象存储中，默认情况下可以使用 &lt;a href="https://velero.io/docs/v1.1.0/aws-config">AWS&lt;/a>、&lt;a href="https://velero.io/docs/v1.1.0/azure-config">Azure&lt;/a>、&lt;a href="https://velero.io/docs/v1.1.0/gcp-config">GCP&lt;/a> 的对象存储，同时也给出了插件功能用来拓展其他平台的存储，这里我们用到的就是阿里云的对象存储 OSS，阿里云也提供了 Velero 的插件，用于将备份存储到 OSS 中。下面我就介绍一下如何在阿里云容器服务 ACK 使用 Velero 完成备份和迁移。&lt;/p>
&lt;blockquote>
&lt;p>Velero 地址：https://github.com/vmware-tanzu/velero&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>ACK 插件地址：https://github.com/AliyunContainerService/velero-plugin&lt;/p>
&lt;/blockquote>
&lt;h3 id="下载-velero-客户端">下载 Velero 客户端&lt;/h3>
&lt;p>Velero 由客户端和服务端组成，服务器部署在目标 k8s 集群上，而客户端则是运行在本地的命令行工具。&lt;/p>
&lt;ul>
&lt;li>前往 &lt;a href="https://github.com/vmware-tanzu/velero/releases">Velero 的 Release 页面&lt;/a> 下载客户端，直接在 GitHub 上下载即可&lt;/li>
&lt;li>解压 release 包&lt;/li>
&lt;li>将 release 包中的二进制文件 &lt;code>velero&lt;/code> 移动到 &lt;code>$PATH&lt;/code> 中的某个目录下&lt;/li>
&lt;li>执行 &lt;code>velero -h&lt;/code> 测试&lt;/li>
&lt;/ul>
&lt;h3 id="创建-oss-bucket">创建 OSS bucket&lt;/h3>
&lt;p>创建一个 OSS bucket 用于存储备份文件，这里也可以用已有的 bucket，之后会在 bucket 中创建 &lt;code>backups&lt;/code>、&lt;code>metadata&lt;/code>、&lt;code>restores&lt;/code>三个目录，这里建议在已有的 bucket 中创建一个子目录用于存储备份文件。&lt;/p>
&lt;p>创建 OSS 的时候一定要选对区域，要和 ACK 集群在同一个区域，存储类型和读写权限选择&lt;strong>标准存储&lt;/strong>和&lt;strong>私有&lt;/strong>：&lt;/p>
&lt;p>&lt;img src="https://tva3.sinaimg.cn/wap720/ad5fbf65gy1g8w7t8c4xbj21021d8thq.jpg" alt="image">&lt;/p>
&lt;h3 id="创建阿里云-ram-用户">创建阿里云 RAM 用户&lt;/h3>
&lt;p>这里需要创建一个阿里云 RAM 的用户，用于操作 OSS 以及 ACK 资源。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>新建权限策略&lt;/p>
&lt;p>&lt;img src="https://tvax4.sinaimg.cn/large/ad5fbf65gy1g8w80cjiv2j21uo18cag8.jpg" alt="image">&lt;/p>
&lt;p>策略内容：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">{
&lt;span style="color:#6ab825;font-weight:bold">&amp;#34;Version&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;1&amp;#34;&lt;/span>,
&lt;span style="color:#6ab825;font-weight:bold">&amp;#34;Statement&amp;#34;&lt;/span>: [
{
&lt;span style="color:#6ab825;font-weight:bold">&amp;#34;Action&amp;#34;&lt;/span>: [
&lt;span style="color:#ed9d13">&amp;#34;ecs:DescribeSnapshots&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;ecs:CreateSnapshot&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;ecs:DeleteSnapshot&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;ecs:DescribeDisks&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;ecs:CreateDisk&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;ecs:Addtags&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;oss:PutObject&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;oss:GetObject&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;oss:DeleteObject&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;oss:GetBucket&amp;#34;&lt;/span>,
&lt;span style="color:#ed9d13">&amp;#34;oss:ListObjects&amp;#34;&lt;/span>
],
&lt;span style="color:#6ab825;font-weight:bold">&amp;#34;Resource&amp;#34;&lt;/span>: [
&lt;span style="color:#ed9d13">&amp;#34;*&amp;#34;&lt;/span>
],
&lt;span style="color:#6ab825;font-weight:bold">&amp;#34;Effect&amp;#34;&lt;/span>: &lt;span style="color:#ed9d13">&amp;#34;Allow&amp;#34;&lt;/span>
}
]
}
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>新建用户&lt;/p>
&lt;p>在新建用户的时候要选择 &lt;code>编程访问&lt;/code>，来获取 &lt;code>AccessKeyID&lt;/code> 和 &lt;code>AccessKeySecret&lt;/code>，这里请创建一个新用于用于备份，不要使用老用户的 AK 和 AS。&lt;/p>
&lt;p>&lt;img src="https://tvax2.sinaimg.cn/large/ad5fbf65gy1g8w8h4ek4uj21h40ue785.jpg" alt="image">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="部署服务端">部署服务端&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>拉取 &lt;a href="https://github.com/AliyunContainerService/velero-plugin">Velero 插件&lt;/a> 到本地&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">git clone https://github.com/AliyunContainerService/velero-plugin
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>配置修改&lt;/p>
&lt;ol>
&lt;li>
&lt;p>修改 &lt;code>install/credentials-velero&lt;/code> 文件，将新建用户中获得的 &lt;code>AccessKeyID&lt;/code> 和 &lt;code>AccessKeySecret&lt;/code> 填入，这里的 OSS EndPoint 为之前 OSS 的访问域名（&lt;strong>注：这里需要选择外网访问的 EndPoint。&lt;/strong>）：&lt;/p>
&lt;p>&lt;img src="https://tvax2.sinaimg.cn/large/ad5fbf65gy1g8w8xd1sgzj21c20cm75z.jpg" alt="image">&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#40ffff">ALIBABA_CLOUD_ACCESS_KEY_ID&lt;/span>=&amp;lt;ALIBABA_CLOUD_ACCESS_KEY_ID&amp;gt;
&lt;span style="color:#40ffff">ALIBABA_CLOUD_ACCESS_KEY_SECRET&lt;/span>=&amp;lt;ALIBABA_CLOUD_ACCESS_KEY_SECRET&amp;gt;
&lt;span style="color:#40ffff">ALIBABA_CLOUD_OSS_ENDPOINT&lt;/span>=&amp;lt;ALIBABA_CLOUD_OSS_ENDPOINT&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>修改 &lt;code>install/01-velero.yaml&lt;/code>，将 OSS 配置填入：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#447fcf;text-decoration:underline">---&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#666"> &lt;/span>velero.io/v1&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">kind&lt;/span>:&lt;span style="color:#666"> &lt;/span>BackupStorageLocation&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">labels&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">component&lt;/span>:&lt;span style="color:#666"> &lt;/span>velero&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>default&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">namespace&lt;/span>:&lt;span style="color:#666"> &lt;/span>velero&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">spec&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">config&lt;/span>:&lt;span style="color:#666"> &lt;/span>{}&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">objectStorage&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">bucket&lt;/span>:&lt;span style="color:#666"> &lt;/span>&amp;lt;ALIBABA_CLOUD_OSS_BUCKET&amp;gt; &lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># OSS bucket 名称&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">prefix&lt;/span>:&lt;span style="color:#666"> &lt;/span>&amp;lt;OSS_PREFIX&amp;gt; &lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># bucket 子目录&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">provider&lt;/span>:&lt;span style="color:#666"> &lt;/span>alibabacloud&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#447fcf;text-decoration:underline">---&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#666"> &lt;/span>velero.io/v1&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">kind&lt;/span>:&lt;span style="color:#666"> &lt;/span>VolumeSnapshotLocation&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">labels&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">component&lt;/span>:&lt;span style="color:#666"> &lt;/span>velero&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>default&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">namespace&lt;/span>:&lt;span style="color:#666"> &lt;/span>velero&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">spec&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">config&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">region&lt;/span>:&lt;span style="color:#666"> &lt;/span>&amp;lt;REGION&amp;gt; &lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># 地域，如果是华东2（上海），则为 cn-shanghai&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">provider&lt;/span>:&lt;span style="color:#666"> &lt;/span>alibabacloud&lt;span style="color:#666">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>k8s 部署 Velero 服务&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#999;font-style:italic"># 新建 namespace&lt;/span>
kubectl create namespace velero
&lt;span style="color:#999;font-style:italic"># 部署 credentials-velero 的 secret&lt;/span>
kubectl create secret generic cloud-credentials --namespace velero --from-file &lt;span style="color:#40ffff">cloud&lt;/span>=install/credentials-velero
&lt;span style="color:#999;font-style:italic"># 部署 CRD&lt;/span>
kubectl apply -f install/00-crds.yaml
&lt;span style="color:#999;font-style:italic"># 部署 Velero&lt;/span>
kubectl apply -f install/01-velero.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>测试 Velero 状态&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ velero version
Client:
Version: v1.1.0
Git commit: a357f21aec6b39a8244dd23e469cc4519f1fe608
Server:
Version: v1.1.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到 Velero 的客户端和服务端已经部署成功。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>服务端清理&lt;/p>
&lt;p>在完成测试或者需要重新安装时，执行如下命令进行清理：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kubectl delete namespace/velero clusterrolebinding/velero
kubectl delete crds -l &lt;span style="color:#40ffff">component&lt;/span>=velero
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h3 id="备份测试">备份测试&lt;/h3>
&lt;p>&lt;code>velero-plugin&lt;/code> 项目中已经给出 &lt;code>example&lt;/code> 用于测试备份。&lt;/p>
&lt;ul>
&lt;li>部署测试服务&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kubectl apply -f examples/base.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>对 &lt;code>nginx-example&lt;/code> 所在的 namespace 进行备份&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">velero backup create nginx-backup --include-namespaces nginx-example --wait
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>模拟 namespace 被误删&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kubectl delete namespaces nginx-example
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>使用 Velero 进行恢复&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">velero restore create --from-backup nginx-backup --wait
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="集群迁移">集群迁移&lt;/h3>
&lt;p>迁移方法同备份，在备份后切换集群，在新集群恢复备份即可。&lt;/p>
&lt;h3 id="高级用法">高级用法&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>定时备份&lt;/p>
&lt;p>对集群资源进行定时备份，则可在发生意外的情况下，进行恢复（默认情况下，备份保留 30 天）。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#999;font-style:italic"># 每日1点进行备份&lt;/span>
velero create schedule &amp;lt;SCHEDULE NAME&amp;gt; --schedule=&lt;span style="color:#ed9d13">&amp;#34;0 1 * * *&amp;#34;&lt;/span>
&lt;span style="color:#999;font-style:italic"># 每日1点进行备份，备份保留48小时&lt;/span>
velero create schedule &amp;lt;SCHEDULE NAME&amp;gt; --schedule=&lt;span style="color:#ed9d13">&amp;#34;0 1 * * *&amp;#34;&lt;/span> --ttl 48h
&lt;span style="color:#999;font-style:italic"># 每6小时进行一次备份&lt;/span>
velero create schedule &amp;lt;SCHEDULE NAME&amp;gt; --schedule=&lt;span style="color:#ed9d13">&amp;#34;@every 6h&amp;#34;&lt;/span>
&lt;span style="color:#999;font-style:italic"># 每日对 web namespace 进行一次备份&lt;/span>
velero create schedule &amp;lt;SCHEDULE NAME&amp;gt; --schedule=&lt;span style="color:#ed9d13">&amp;#34;@every 24h&amp;#34;&lt;/span> --include-namespaces web
&lt;/code>&lt;/pre>&lt;/div>&lt;p>定时备份的名称为：&lt;code>&amp;lt;SCHEDULE NAME&amp;gt;-&amp;lt;TIMESTAMP&amp;gt;&lt;/code>，恢复命令为：&lt;code>velero restore create --from-backup &amp;lt;SCHEDULE NAME&amp;gt;-&amp;lt;TIMESTAMP&amp;gt;&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>备份删除&lt;/p>
&lt;p>直接执行命令进行删除&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">velero delete backups &amp;lt;BACKUP_NAME&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>备份资源查看&lt;/p>
&lt;p>备份查看&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">velero backup get
&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看定时备份&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">velero schedule get
&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看可恢复备份&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">velero restore get
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>备份排除项目&lt;/p>
&lt;p>可为资源添加指定标签，添加标签的资源在备份的时候被排除。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#999;font-style:italic"># 添加标签&lt;/span>
kubectl label -n &amp;lt;ITEM_NAMESPACE&amp;gt; &amp;lt;RESOURCE&amp;gt;/&amp;lt;NAME&amp;gt; velero.io/exclude-from-backup=&lt;span style="color:#24909d">true&lt;/span>
&lt;span style="color:#999;font-style:italic"># 为 default namespace 添加标签&lt;/span>
kubectl label -n default namespace/default velero.io/exclude-from-backup=&lt;span style="color:#24909d">true&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h3 id="问题汇总">问题汇总&lt;/h3>
&lt;h4 id="时区问题">时区问题&lt;/h4>
&lt;p>进行定时备份时，发现备份使用的事 UTC 时间，并不是本地时间，经过排查后发现是 &lt;code>velero&lt;/code> 镜像的时区问题，在调整后就会正常定时备份了，这里我重新调整了时区，直接调整镜像就好，修改 &lt;code>install/01-velero.yaml&lt;/code> 文件，将镜像替换为 &lt;code>registry-vpc.cn-shanghai.aliyuncs.com/keking/velero:latest&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#6ab825;font-weight:bold">image&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">caption&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#ed9d13">&amp;#34;Image from: [**Pexels**](https://www.pexels.com)&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">focal_point&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#ed9d13">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">preview_only&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">false&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#447fcf;text-decoration:underline">---&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#666"> &lt;/span>extensions/v1beta1&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">kind&lt;/span>:&lt;span style="color:#666"> &lt;/span>Deployment&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>velero&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">namespace&lt;/span>:&lt;span style="color:#666"> &lt;/span>velero&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">spec&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">replicas&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#3677a9">1&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">selector&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">matchLabels&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">deploy&lt;/span>:&lt;span style="color:#666"> &lt;/span>velero&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">template&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">annotations&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">prometheus.io/path&lt;/span>:&lt;span style="color:#666"> &lt;/span>/metrics&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">prometheus.io/port&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#ed9d13">&amp;#34;8085&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">prometheus.io/scrape&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#ed9d13">&amp;#34;true&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">labels&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">component&lt;/span>:&lt;span style="color:#666"> &lt;/span>velero&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">deploy&lt;/span>:&lt;span style="color:#666"> &lt;/span>velero&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">spec&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">serviceAccountName&lt;/span>:&lt;span style="color:#666"> &lt;/span>velero&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">containers&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>velero&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># sync from gcr.io/heptio-images/velero:latest&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">image&lt;/span>:&lt;span style="color:#666"> &lt;/span>registry-vpc.cn-shanghai.aliyuncs.com/keking/velero:latest &lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># 修复时区后的镜像&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">imagePullPolicy&lt;/span>:&lt;span style="color:#666"> &lt;/span>IfNotPresent&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">command&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- /velero&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">args&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- server&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- --default-volume-snapshot-locations=alibabacloud:default&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">env&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>VELERO_SCRATCH_DIR&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">value&lt;/span>:&lt;span style="color:#666"> &lt;/span>/scratch&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>ALIBABA_CLOUD_CREDENTIALS_FILE&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">value&lt;/span>:&lt;span style="color:#666"> &lt;/span>/credentials/cloud&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">volumeMounts&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">mountPath&lt;/span>:&lt;span style="color:#666"> &lt;/span>/plugins&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>plugins&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">mountPath&lt;/span>:&lt;span style="color:#666"> &lt;/span>/scratch&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>scratch&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">mountPath&lt;/span>:&lt;span style="color:#666"> &lt;/span>/credentials&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>cloud-credentials&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">initContainers&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">image&lt;/span>:&lt;span style="color:#666"> &lt;/span>registry.cn-hangzhou.aliyuncs.com/acs/velero-plugin-alibabacloud:v1.2&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">imagePullPolicy&lt;/span>:&lt;span style="color:#666"> &lt;/span>IfNotPresent&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>velero-plugin-alibabacloud&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">volumeMounts&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">mountPath&lt;/span>:&lt;span style="color:#666"> &lt;/span>/target&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>plugins&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">volumes&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">emptyDir&lt;/span>:&lt;span style="color:#666"> &lt;/span>{}&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>plugins&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">emptyDir&lt;/span>:&lt;span style="color:#666"> &lt;/span>{}&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>scratch&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>cloud-credentials&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">secret&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">secretName&lt;/span>:&lt;span style="color:#666"> &lt;/span>cloud-credentials&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="版本问题">版本问题&lt;/h4>
&lt;p>截止发稿时，Velero 已经发布了 v1.2.0 版本，目前 ACK 的 Velero 的插件还未升级。&lt;/p>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>近日正好有 k8s 集群服务迁移服务的需求，使用 Velero 完成了服务的迁移，同时也每日进行集群资源备份，其能力可以满足容器服务的灾备和迁移场景，实测可用，现已运行在所有的 k8s 集群。&lt;/p></description></item><item><title>Post: 使用 Grafana 展示阿里云监控指标</title><link>https://guoxudong.io/post/aliyun-cms-grafana/</link><pubDate>Thu, 07 Nov 2019 11:08:36 +0800</pubDate><guid>https://guoxudong.io/post/aliyun-cms-grafana/</guid><description>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>对于阿里云用户来说，阿里云监控是一个很不错的产品，首先它在配额内使用是免费的！免费的！免费的！重要的事情说三遍。他的功能类似于 zabbix，但是比 zabbix 提供了更多的监控项，基本上在云上使用的资源都可以通过云监控来实时监控。而它提供的开箱即用方式，天然集成云资源，并提供多种告警方式，免去了监控与告警系统搭建与维护的繁琐，并且减少了资源的消耗，比购买 ECS 自己搭建 zabbix 要少消耗很多资源。同时阿里云监控和阿里云其他服务一样，也提供了比较完整的 OpenApi 以及各种语言的 sdk，可以基于阿里云的 OpenApi 将其与自己的系统集成。我们之前也是这么做的，但是随着监控项的增加，以及经常需要在办公场地监控投屏的专项监控页，光凭我们的运维开发工程师使用 vue 写速度明显跟不上，而且页面的美观程度也差很多。&lt;/p>
&lt;h3 id="手写前端-vs-grafana">手写前端 VS Grafana&lt;/h3>
&lt;p>手写前端虽然可定制化程度更高，但是需要消耗大量精力进行调试，对于运维人员，哪怕是运维开发也是吃不消的（前端小哥哥和小姐姐是不会来帮你的，下图就是我去年拿 vue 写的伪 Grafana 展示页面，花费了大约一周时间在调整这些前端元素）。
&lt;img src="https://tva4.sinaimg.cn/large/ad5fbf65gy1g8pfrw1licj22ye1gg4qp.jpg" alt="image">&lt;/p>
&lt;p>Grafana 则标准化程度很高，展示也更加符合大众审美，某些定制化需求可以通过自定义 DataSource 或者 AJAX 插件的 iframe 模式完成。开发后端 DataSource 肯定就没有前端调整 css 那么痛苦和耗时了，整体配置开发一个这样的页面可能只消耗一人天就能完成。而在新产品上线时，构建一个专项监控展示页面速度就更快了，几分钟内就能完成。
&lt;img src="https://tva4.sinaimg.cn/large/ad5fbf65gy1g8pfvp0keej22yc1g2khm.jpg" alt="image">&lt;/p>
&lt;h2 id="关于阿里云监控">关于阿里云监控&lt;/h2>
&lt;p>云监控（CloudMonitor）是一项针对阿里云资源和互联网应用进行监控的服务。&lt;/p>
&lt;p>云监控为云上用户提供开箱即用的企业级开放型一站式监控解决方案。涵盖 IT 设施基础监控，外网网络质量拨测监控，基于事件、自定义指标、日志的业务监控。为您全方位提供更高效、更全面、更省钱的监控服务。通过提供跨产品、跨地域的应用分组管理模型和报警模板，帮助您快速构建支持几十种云产品、管理数万实例的高效监控报警管理体系。通过提供 Dashboard，帮助您快速构建自定义业务监控大盘。使用云监控，不但可以帮助您提升您的系统服务可用时长，还可以降低企业 IT 运维监控成本。&lt;/p>
&lt;p>云监控服务可用于收集获取阿里云资源的监控指标或用户自定义的监控指标，探测服务可用性，以及针对指标设置警报。使您全面了解阿里云上的资源使用情况、业务的运行状况和健康度，并及时收到异常报警做出反应，保证应用程序顺畅运行。&lt;/p>
&lt;h2 id="关于-grafana">关于 Grafana&lt;/h2>
&lt;p>Grafana 是一个跨平台的开源的度量分析和可视化工具，可以通过将采集的数据查询然后可视化的展示，并及时通知。由于云监控的 Grafana 还没有支持告警，所以我们这里只用了 Grafana 的可视化功能，而告警本身就是云监控自带的，所以也不需要依赖 Grafana 来实现。而我们的 Prometheus 也使用了 Grafana 进行数据可视化，所以有现成的 Grafana-Server 使用。&lt;/p>
&lt;h2 id="阿里云监控对接-grafana">阿里云监控对接 Grafana&lt;/h2>
&lt;p>首先 Grafana 服务的部署方式这里就不做介绍了，请使用较新版本的 Grafana，最好是 5.5.0+。后文中也有我开源的基于阿里云云监控的 Grafana 的 helm chart，可以使用 helm 安装，并会直接导入云监控的指标，这个会在后文中介绍。&lt;/p>
&lt;h3 id="安装阿里云监控插件">安装阿里云监控插件&lt;/h3>
&lt;p>进入插件目录进行安装&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#24909d">cd&lt;/span> /var/lib/grafana/plugins/
git clone https://github.com/aliyun/aliyun-cms-grafana.git
service grafana-server restart
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果是使用 docker 或者部署在 k8s 集群，这里也可以使用环境变量在 Grafana 部署的时候进行安装&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#447fcf;text-decoration:underline">...&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">spec&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">containers&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">env&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>GF_INSTALL_PLUGINS &lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># 多个插件请使用,隔开&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">value&lt;/span>:&lt;span style="color:#666"> &lt;/span>grafana-simple-json-datasource,https://github.com/aliyun/aliyun-cms-grafana/archive/master.zip;aliyun-cms-grafana&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#447fcf;text-decoration:underline">...&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>您也可以下载 aliyun-cms-grafana.zip 插件解压后，上传服务器的 Grafana 的 plugins 目录下，重启 grafana-server 即可。&lt;/p>
&lt;h3 id="配置云监控-datasource">配置云监控 DataSource&lt;/h3>
&lt;ol>
&lt;li>Grafana 启动后，进入 &lt;code>Configuration&lt;/code> 页面，选择 &lt;code>DataSource&lt;/code> Tab 页，单击右上方的&lt;code>Add data source&lt;/code>，添加数据源。&lt;/li>
&lt;li>选中&lt;code>CMS Grafana Service&lt;/code>，单击&lt;code>select&lt;/code>。
&lt;img src="https://tvax2.sinaimg.cn/large/ad5fbf65gy1g8ph0ukr0pj21nm0jk76m.jpg" alt="image">&lt;/li>
&lt;li>填写配置项，URL 根据云监控所在地域填写，并且填写阿里云账号的 accessKeyId 和 accessSecret，完成后单击&lt;code>Save&amp;amp;Test&lt;/code>。
&lt;img src="https://tvax3.sinaimg.cn/large/ad5fbf65gy1g8ph4bg2bij218m194n9f.jpg" alt="image">&lt;/li>
&lt;/ol>
&lt;h3 id="创建-dashboard">创建 Dashboard&lt;/h3>
&lt;ol>
&lt;li>单击 &lt;code>Create&lt;/code> -&amp;gt; &lt;code>Dashboard&lt;/code> -&amp;gt; &lt;code>Add Query&lt;/code>&lt;/li>
&lt;li>配置图标，数据源选择之前添加的 &lt;code>CMS Grafana Service&lt;/code>，然后文档中的配置项填入指标即可（这里要注意的是，云监控 API 给返回的只有实例 ID，并没有自定义的实例名称，这里需要手动将其填入 &lt;code>Y - column describe&lt;/code> 中；而且只支持输入单个 Dimension，若输入多个，默认选第一个，由于这些问题才有了后续我开发的 &lt;code>cms-grafana-builder&lt;/code> 的动机）。
&lt;img src="https://tva4.sinaimg.cn/large/ad5fbf65gy1g8phck0irbj22ye13in79.jpg" alt="image">&lt;/li>
&lt;li>配置参考 &lt;a href="https://help.aliyun.com/document_detail/28619.html">云产品监控项&lt;/a>，
&lt;img src="https://tva2.sinaimg.cn/large/ad5fbf65gy1g8phg832uvj21a40vo793.jpg" alt="image">&lt;/li>
&lt;/ol>
&lt;h2 id="使用-helm-chart-的方式部署-grafana">使用 helm chart 的方式部署 Grafana&lt;/h2>
&lt;p>项目地址：https://github.com/sunny0826/cms-grafana-builder&lt;/p>
&lt;h3 id="cms-grafana-builder">cms-grafana-builder&lt;/h3>
&lt;p>由于上文中的问题，我们需要手动选择每个实例 ID 到 Dimension 中，并且还要讲该实例的名称键入 &lt;code>Y - column describe&lt;/code> 中，十分的繁琐，根本不可能大批量的输入。&lt;/p>
&lt;p>这就是我开发这个 Grafana 指标参数生成器的原因，起初只是一个 python 脚本，用来将我们要监控的指标组装成一个 Grafana 可以使用 json 文件，之后结合 Grafana 的容器化部署方法，将其做成了一个 helm chart。可以在启动的时候自动将需要的参数生成，并且每日会对所有指标进行更新，这样就不用每次新购或者释放掉资源后还需要再跑一遍脚本。&lt;/p>
&lt;h3 id="部署">部署&lt;/h3>
&lt;p>只需要将项目拉取下来运行 &lt;code>helm install&lt;/code> 命令&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">helm install my-release kk-grafana-cms &lt;span style="color:#ed9d13">\
&lt;/span>&lt;span style="color:#ed9d13">&lt;/span>--namespace {your_namespace} &lt;span style="color:#ed9d13">\
&lt;/span>&lt;span style="color:#ed9d13">&lt;/span>--set &lt;span style="color:#40ffff">access_key_id&lt;/span>={your_access_key_id} &lt;span style="color:#ed9d13">\
&lt;/span>&lt;span style="color:#ed9d13">&lt;/span>--set &lt;span style="color:#40ffff">access_secret&lt;/span>={your_access_secret} &lt;span style="color:#ed9d13">\
&lt;/span>&lt;span style="color:#ed9d13">&lt;/span>--set &lt;span style="color:#40ffff">region_id&lt;/span>={your_aliyun_region_id} &lt;span style="color:#ed9d13">\
&lt;/span>&lt;span style="color:#ed9d13">&lt;/span>--set &lt;span style="color:#40ffff">password&lt;/span>={admin_password}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>更多详情见 &lt;a href="https://github.com/sunny0826/cms-grafana-builder">github README&lt;/a>，欢迎提 issue 交流。&lt;/p>
&lt;h3 id="指标选择">指标选择&lt;/h3>
&lt;p>在部署成功后，可修改 ConfigMap：&lt;code>grafana-cms-metric&lt;/code>，然后修改对应的监控指标项。&lt;/p>
&lt;h3 id="效果">效果&lt;/h3>
&lt;p>ECS:
&lt;img src="https://tvax1.sinaimg.cn/large/ad5fbf65gy1g8pi9toh3dj21gv0pldyf.jpg" alt="">&lt;/p>
&lt;p>RDS:
&lt;img src="https://tva2.sinaimg.cn/large/ad5fbf65gy1g8pi9o91ejj21h80q316p.jpg" alt="">&lt;/p>
&lt;p>EIP:
&lt;img src="https://tva4.sinaimg.cn/large/ad5fbf65gy1g8pi9i9if3j21h70q3aif.jpg" alt="">&lt;/p>
&lt;p>Redis:
&lt;img src="https://tvax1.sinaimg.cn/large/ad5fbf65gy1g8pi8ss733j21h30pz7b6.jpg" alt="">&lt;/p>
&lt;h2 id="后记">后记&lt;/h2>
&lt;p>为了满足公司需求，后续还开发 DataSource 定制部分，用于公司监控大屏的展示，这部分是另一个项目，不在这个项目里，就不细说了，之后有机会总结后再进行分享。&lt;/p></description></item><item><title>Post: 阿里云产品夜谈-容器服务交流</title><link>https://guoxudong.io/post/aliyun-product-meetup/</link><pubDate>Mon, 30 Sep 2019 09:32:35 +0800</pubDate><guid>https://guoxudong.io/post/aliyun-product-meetup/</guid><description>
&lt;p>&lt;img src="https://tvax4.sinaimg.cn/large/ad5fbf65gy1g7hb4iwdpvj213i0vs4qq.jpg" alt="image">&lt;/p>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>9月25日晚受邀来到阿里云飞天园区参加阿里云MVP产品夜谈，在会上遇到了容器服务团队的负责人易立，并就容器服务进行了交流。此次参加夜谈的除了来自全球各地的阿里云MVP，还有来自安全团队、容器团队、AIoT 团队、大数据团队、数据库团队、人工智能团队、中间件团队、搜索引擎&amp;amp;智能推荐团队的负责人&amp;amp;产品经理。各个参会的MVP可以根据自己的研究方向或者感兴趣的方向选择，直接与团队负责人面对面交流，获取阿里云产品的最新信息，并提出使用意见，促进产品的发展。由于主要从事云原生&amp;amp;容器方面的工作，我选择了容器团队，与阿里云容器服务团队负责人易立就容器服务进行交流，本文记录了部分交流内容。&lt;/p>
&lt;h2 id="容器服务交流">容器服务交流&lt;/h2>
&lt;p>&lt;img src="https://tva3.sinaimg.cn/large/ad5fbf65gy1g7hdbw7rwij21zk13ax6s.jpg" alt="">&lt;/p>
&lt;h3 id="关于集群版本集群升级">关于集群版本&amp;amp;集群升级&lt;/h3>
&lt;p>众所周知，Kubernetes 以非常稳定的3个月发布一个版本速度在高速迭代这，Kubernetes v1.16.0 也即将 release ，但是目前 ACK 的 Kubernetes 版本依旧为 v1.12.6-aliyun.1 已落后官方4个大版本。得到的回复是新版本 1.14 已经上线，下周就可以升级了，1.14 版本之前已经上线，只不过一直在灰度测试，下周（2019年9月29日）就全面放开升级了。截止写这篇文章的时候，我们的多个 Kubernetes 集群已成功升级到 v1.14.6-aliyun.1 ，虽然在升级的时候出现了一点小问题，但是最后还是顺利解决了。&lt;/p>
&lt;p>然后就是集群升级的问题，集群升级的时候会建议对所有节点打快照，确保节点安全，但是如果在节点升级当中失败，就会出现一半为新版本节点，一半为旧版本节点的问题。我们的一个节点升级失败，就出现了上述问题，最后还是将该节点容器驱散，并将该节点移出集群才解决了升级问题。希望集群升级提供整体状态保存&amp;amp;回退功能，确保如果升级失败（或者出现新旧版本不兼容问题）的时候可以安全回退到之前版本。&lt;/p>
&lt;h3 id="关于容器服务前端展示">关于容器服务前端展示&lt;/h3>
&lt;p>ACK 的 WEB 界面相对简陋，一直以来都是对 Kubernetes Dashboard 进行了简单的包装，和其他公有云相比确实不如。不过这也不是容器服务独有的问题，阿里云你产品众多，大部分都有这样的问题。与易立交流得知，容器服务团队目前主要的任务还是确保 Kubernetes 集群的安全稳定运行，他们在安全和可用性上花费的大量精力，貌似并没有拿到什么前端开发资源。我注意到像费用中心、日志服务等产品都有了新版页面，这里希望能容器服务页面也能尽快改版，提高页面操作的便捷和美观。&lt;/p>
&lt;h3 id="关于授权管理">关于授权管理&lt;/h3>
&lt;p>一直以来容器服务都有授权管理功能，后来都基于RAM重新做了授权管理功能。但是RAM权限管理策略十分复杂，配置起来也很麻烦，不同的策略结构和语法学习起来非常困难。在配置和管理起来非常困难，我们只能把所有权限收回，每项权限都要根据需求提工单来进行配置，还时长会出现配置不生效的问题。而且这个问题一提出，就引起了大家的共鸣，后了解得知，为了安全合规的要求，操作便捷和安全合规没法兼顾。这里希望授权管理上能在确保合规的同时，能提升RAM操作的便捷性。&lt;/p>
&lt;h2 id="后记">后记&lt;/h2>
&lt;p>&lt;img src="https://tvax2.sinaimg.cn/large/ad5fbf65gy1g7hdrlln6vj21rm0ycwov.jpg" alt="image">
关于容器服务的交流主要是以上几点，其他的还包括监控、存储和 CI/CD 方面进行了交流，同时也获得了不少建议。当面给阿里云提需求的机会并不多，我也是抓住机会，把日常使用 ACK 的问题汇总之后一股脑的丢了出去。有类似需求的同学可以在&lt;a href="https://connect.aliyun.com">阿里云的聆听平台&lt;/a>上给阿里云提交建议，以我的经验，合理的需求会很快审核通过并排期开发，换句话说就是“人人都可以是阿里云的产品经理”。&lt;/p></description></item><item><title>Post: 解决 Nginx-Ingress 重定向失败问题</title><link>https://guoxudong.io/post/nginx-ingress-error/</link><pubDate>Fri, 16 Aug 2019 11:15:37 +0800</pubDate><guid>https://guoxudong.io/post/nginx-ingress-error/</guid><description>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>最近对公司 Kubernetes 集群的 &lt;code>nginx-ingress-controller&lt;/code> 进行了升级，但是升级后却出现了大问题，之前所有采用 &lt;code>nginx.ingress.kubernetes.io/rewrite-target: /&lt;/code> 注释进行重定向的 Ingress 路由全部失效了，但是那些直接解析了域名，没有进行重定向的却没有发生这个问题。&lt;/p>
&lt;h2 id="问题分析">问题分析&lt;/h2>
&lt;ol>
&lt;li>首先检查对应服务健康状态，发现所有出问题的服务的状态均正常，同时受影响的之后 http 调用，而 RPC 调用却不受影响，这时问题就定位到了 ingress。&lt;/li>
&lt;li>然后检查 nginx-ingress-controller ，发现 nginx-ingress-controller 的状态也是正常的，路由也是正常的。&lt;/li>
&lt;li>最后发现受影响的只有添加了重定向策略的 ingress 。&lt;/li>
&lt;/ol>
&lt;h2 id="问题解决">问题解决&lt;/h2>
&lt;p>问题已经定位，接下来就是着手解决问题，这时候值得注意的就是之前进行了什么变更：升级了 nginx-ingress-controller 版本！看来问题就出现在新版本上，那么就打开官方文档：https://kubernetes.github.io/ingress-nginx/examples/rewrite/ 看一下吧。&lt;/p>
&lt;h3 id="attention">Attention&lt;/h3>
&lt;blockquote>
&lt;p>Starting in Version 0.22.0, ingress definitions using the annotation &lt;code>nginx.ingress.kubernetes.io/rewrite-target&lt;/code> are not backwards compatible with previous versions. In Version 0.22.0 and beyond, any substrings within the request URI that need to be passed to the rewritten path must explicitly be defined in a &lt;a href="https://www.regular-expressions.info/refcapture.html">capture group&lt;/a>.&lt;/p>
&lt;/blockquote>
&lt;p>文档上给出了非常明显的警告⚠️：从 V0.22.0 版本开始将不再兼容之前的入口定义，再查看一下我的 nginx-ingress-controller 版本，果然问题出现来这里。&lt;/p>
&lt;h3 id="note">Note&lt;/h3>
&lt;blockquote>
&lt;p>&lt;a href="https://www.regular-expressions.info/refcapture.html">Captured groups&lt;/a> are saved in numbered placeholders, chronologically, in the form &lt;code>$1&lt;/code>, &lt;code>$2&lt;/code> &amp;hellip; &lt;code>$n&lt;/code>. These placeholders can be used as parameters in the &lt;code>rewrite-target&lt;/code> annotation.&lt;/p>
&lt;/blockquote>
&lt;h3 id="示例">示例&lt;/h3>
&lt;p>到这里问题已经解决了，在更新了 ingress 的配置之后，之前所有无法重定向的服务现在都已经可以正常访问了。修改见如下示例：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ &lt;span style="color:#24909d">echo&lt;/span> &lt;span style="color:#ed9d13">&amp;#39;
&lt;/span>&lt;span style="color:#ed9d13">apiVersion: extensions/v1beta1
&lt;/span>&lt;span style="color:#ed9d13">kind: Ingress
&lt;/span>&lt;span style="color:#ed9d13">metadata:
&lt;/span>&lt;span style="color:#ed9d13"> annotations:
&lt;/span>&lt;span style="color:#ed9d13"> nginx.ingress.kubernetes.io/rewrite-target: /$2
&lt;/span>&lt;span style="color:#ed9d13"> name: rewrite
&lt;/span>&lt;span style="color:#ed9d13"> namespace: default
&lt;/span>&lt;span style="color:#ed9d13">spec:
&lt;/span>&lt;span style="color:#ed9d13"> rules:
&lt;/span>&lt;span style="color:#ed9d13"> - host: rewrite.bar.com
&lt;/span>&lt;span style="color:#ed9d13"> http:
&lt;/span>&lt;span style="color:#ed9d13"> paths:
&lt;/span>&lt;span style="color:#ed9d13"> - backend:
&lt;/span>&lt;span style="color:#ed9d13"> serviceName: http-svc
&lt;/span>&lt;span style="color:#ed9d13"> servicePort: 80
&lt;/span>&lt;span style="color:#ed9d13"> path: /something(/|$)(.*)
&lt;/span>&lt;span style="color:#ed9d13">&amp;#39;&lt;/span> | kubectl create -f -
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="结语">结语&lt;/h2>
&lt;p>解决这个问题的实际时间虽然不长，但是着实让人出了一身冷汗，同时也给了我警示：变更有风险，升级需谨慎。在升级之前需要先浏览新版本的升级信息，同时需要制定完善的回滚策略，确保万无一失。&lt;/p></description></item><item><title>Post: 阿里云 ACK 挂载 NAS 数据卷</title><link>https://guoxudong.io/post/nas-k8s/</link><pubDate>Mon, 08 Jul 2019 15:09:56 +0800</pubDate><guid>https://guoxudong.io/post/nas-k8s/</guid><description>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>今天接到一个将 NAS 数据卷挂载到 Kubernetes 集群的需求，需要将一个 NAS 数据卷挂载到集群中。这一很简单的操作由于好久没有操作了，去翻看了一下官方文档，发现官方文档还在停留在去年7月份&amp;hellip;为了防止之后还有相似情况的发生，这里将所有操作做一个简单记录。&lt;/p>
&lt;h2 id="购买存储包创建文件系统">购买存储包（创建文件系统）&lt;/h2>
&lt;p>在挂载 NAS 之前，首先要先购买 NAS 文件存储，这里推荐购买存储包，100G 的 SSD 急速型一年只需1400多，而容量型只要279，对于我这种只有少量 NAS 存储需求的人来说是是靠谱的，因为我只需要5G的左右的存储空间，SSD 急速型 NAS 一年只要18块，完美。&lt;/p>
&lt;p>&lt;img src="https://tva2.sinaimg.cn/large/ad5fbf65gy1g4sglwrx0gj22wa09gae4.jpg" alt="image">&lt;/p>
&lt;p>选择想要创建 NAS 所在 VPC 和 区域&lt;/p>
&lt;h2 id="添加挂载点">添加挂载点&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>点击添加挂载点
&lt;img src="https://tva2.sinaimg.cn/large/ad5fbf65gy1g4sgp0dos2j22ky0iowkr.jpg" alt="image">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>选择 VPC 网络、交换机和权限组
&lt;img src="https://wx2.sinaimg.cn/large/ad5fbf65gy1g4sgpwqrgoj20xu0vowib.jpg" alt="image">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="linux-挂载-nas-数据卷">Linux 挂载 NAS 数据卷&lt;/h2>
&lt;p>在挂载点创建成功后，就可以将 NAS 数据卷挂载到 Linux 系统，这里以 CentOS 为例：&lt;/p>
&lt;h3 id="安装-nfs-客户端">安装 NFS 客户端&lt;/h3>
&lt;p>如果 Linux 系统要挂载 NAS ，首先需要安装 NFS 客户端&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">sudo yum install nfs-utils
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="挂载-nfs-文件系统">挂载 NFS 文件系统&lt;/h3>
&lt;p>这里阿里云早就进行了优化，点击创建的文件系统，页面上就可以 copy 挂载命令。页面提供了挂载地址的 copy 和挂载命令的 copy 功能。&lt;/p>
&lt;p>&lt;img src="https://wx2.sinaimg.cn/large/ad5fbf65gy1g4sh2i33wnj22w40yyn55.jpg" alt="image">&lt;/p>
&lt;p>挂载命令：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">sudo mount -t nfs -o &lt;span style="color:#40ffff">vers&lt;/span>=4,minorversion=0,noresvport xxxxx.cn-shanghai.nas.aliyuncs.com:/ /mnt
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="查看挂载结果">查看挂载结果&lt;/h3>
&lt;p>直接在挂载数据卷所在服务上执行命令：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">df -h
&lt;/code>&lt;/pre>&lt;/div>&lt;p>就可以看到结果：&lt;/p>
&lt;p>&lt;img src="https://tva2.sinaimg.cn/large/ad5fbf65gy1g4sh6xwyt8j20lj0850tq.jpg" alt="image">&lt;/p>
&lt;h2 id="kubernetes-集群挂载-nas-数据卷">Kubernetes 集群挂载 NAS 数据卷&lt;/h2>
&lt;p>K8S 的持久数据卷挂载大同小异，流程都是：&lt;strong>创建PV&lt;/strong> -&amp;gt; &lt;strong>创建PVC&lt;/strong> -&amp;gt; &lt;strong>使用PVC&lt;/strong>&lt;/p>
&lt;p>下面就简单介绍在阿里云上的操作：&lt;/p>
&lt;h3 id="创建存储卷pv">创建存储卷（PV）&lt;/h3>
&lt;p>首先要创建存储卷，选择 &lt;strong>容器服务&lt;/strong> -&amp;gt; &lt;strong>存储卷&lt;/strong> -&amp;gt; &lt;strong>创建&lt;/strong>&lt;/p>
&lt;p>这里要注意的是：&lt;strong>挂载点域名使用上面面的挂载地址&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://wx4.sinaimg.cn/large/ad5fbf65gy1g4shuiiyyqj20hc0hp0tz.jpg" alt="image">&lt;/p>
&lt;h3 id="创建存储声明pvc">创建存储声明（PVC）&lt;/h3>
&lt;p>&lt;strong>选择 NAS&lt;/strong> -&amp;gt; &lt;strong>已有存储卷&lt;/strong>&lt;/p>
&lt;p>选择刚才创建的存储卷&lt;/p>
&lt;p>&lt;img src="https://ws4.sinaimg.cn/large/ad5fbf65gy1g4shv5vs1kj20hx0bvt9g.jpg" alt="image">&lt;/p>
&lt;h3 id="使用pvc">使用PVC&lt;/h3>
&lt;p>使用的方法这里就不做详细介绍了，相关文章也比较多，这里就只记录 Deployment 中使用的 yaml 片段：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#447fcf;text-decoration:underline">...&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">volumeMounts&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">mountPath&lt;/span>:&lt;span style="color:#666"> &lt;/span>/data &lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># 挂载路径&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>volume-nas-test&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#447fcf;text-decoration:underline">...&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">volumes&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>volume-nas-test&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">persistentVolumeClaim&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">claimName&lt;/span>:&lt;span style="color:#666"> &lt;/span>nas-test &lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># PVC 名称&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#447fcf;text-decoration:underline">...&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="结语">结语&lt;/h2>
&lt;p>这里只是做一个简单的记录，仅适用于阿里云 ACK 容器服务，同时也是 ACK 的一个简单应用。由于不经常对数据卷进行操作，这里做简单的记录，防止以后使用还要再看一遍文档。&lt;/p></description></item><item><title>Post: 4月29日 云栖社区分享PPT -- 阿里云容器服务的优势与调优</title><link>https://guoxudong.io/post/aliyun-share/</link><pubDate>Tue, 30 Apr 2019 18:46:24 +0800</pubDate><guid>https://guoxudong.io/post/aliyun-share/</guid><description>
&lt;p>该PPT 为 2019年4月26日 在云栖社区分享使用，这里留作展示和记录，下载地址可以参考下方链接。&lt;/p>
&lt;iframe src="https://guoxudong.io/aliyun-share/index.html" style="width: 100%;height:600px;" frameborder="0">&lt;/iframe>
&lt;p>由于图片资源位于 GitHub 上，国内访问可能会有些慢，建议下载观看。&lt;/p>
&lt;p>PPT 下载地址：https://yq.aliyun.com/articles/700084&lt;/p></description></item><item><title>Post: 阿里云容器服务新建集群优化方案(更新版)</title><link>https://guoxudong.io/post/aliyun-k8s-perfect/</link><pubDate>Thu, 25 Apr 2019 22:26:06 +0800</pubDate><guid>https://guoxudong.io/post/aliyun-k8s-perfect/</guid><description>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>选择阿里云的&lt;code>容器服务&lt;/code>，主要原因是公司主要业务基本都在运行在阿里云上。相较自建 kubernetes 集群，容器服务的优势在于部署相对简单，与阿里云 VPC 完美兼容，网络的配置相对简单，而如果使用 &lt;code>kubeadm&lt;/code> 安装部署 kubernetes 集群，除了众所周知的科学上网的问题，还有一系列的问题，包括 &lt;code>etcd&lt;/code> 、 &lt;code>Scheduler&lt;/code> 和 &lt;code>Controller-Manager&lt;/code> 的高可用问题等。并且如果使用托管版的阿里云 kubernetes 容器服务，还会省掉3台 master 节点的钱，并且可能将 master 节点的运维问题丢给阿里云解决，并且其提供的 master 节点性能肯定会比自购的配置好，这点是阿里云容器服务的研发小哥在来我司交流时专门强调的。&lt;/p>
&lt;h2 id="问题">问题&lt;/h2>
&lt;p>前面吹了阿里云容器服务的优势，那这里就说说在实践中遇到的容器服务的问题：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在新建集群的时候需要选择相应的 VPC 并选择 &lt;code>Pod&lt;/code> 和 &lt;code>Service&lt;/code> 所在的网段，这两个网段不能和 Node 节点存在于同一网段，但是如果您在阿里云中存在不止一个 VPC （VPC的网段可以是 10.0.0.0/8，172.16-31.0.0/12-16，192.168.0.0/16 ），如果网段设置不对的话，就可能会使原本存在该网段的 ECS 失联，需要删除集群重新创建。如果删除失败的话，还需要手动删除路由表中的记录（&lt;strong>别问我是怎么知道的&lt;/strong>）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在使用容器服务创建集群后，会创建2个 SLB （之前是3个），一个是 SLB 是在 VPC 上并且绑定一个弹性IP（需要在创建的时候手动勾选创建弹性IP）用于 API Server，一个是经典网络的 SLB 使用提供给 Ingress 使用。但是这两个外网IP创建后的规格都是默认最大带宽、按流量收费，这个并不符合我们的要求，需要手动修改，&lt;del>然而这个修改都会在第二天才能生效&lt;/del>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>容器服务创建集群后，Node 节点的名称会使&lt;code>{region-id}.{ECS-id}&lt;/code>的形式，这个命名方式在集群监控，使用 &lt;code>kubectl&lt;/code> 操作集群方面就显得比较反人类了，每次都要去查 &lt;code>ECS id&lt;/code> 才能确定是哪个节点，而这个 Node 节点名称是不能修改的！&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="网段问题解决">网段问题解决&lt;/h2>
&lt;p>这个比较好解决，甚至可以说不用解决，只要把网段规划好，不要出现网段冲突就好&lt;/p>
&lt;h2 id="node-节点名称无法修改问题解决">Node 节点名称无法修改问题解决&lt;/h2>
&lt;p>这个功能之前已有人在阿里聆听平台提出这个问题了，咨询了容器服务的研发小哥，得到的反馈是该功能已经在灰度测试了，相信很快就可以上线了。&lt;/p>
&lt;h2 id="创建-slb-规格问题解决">创建 SLB 规格问题解决&lt;/h2>
&lt;p>相较之前自动创建3个 SLB 的方式，目前的版本只会自动创建2个并且有一个是 VPC 内网+弹性IP的方式，已经进行了优化，但是 ingress 绑定的 SLB 还是经典网络类型，无法接入云防火墙并且规格也是不合适的。这里给出解决方案：&lt;/p>
&lt;h3 id="方法一使用-kubectl-配置">方法一：使用 &lt;code>kubectl&lt;/code> 配置&lt;/h3>
&lt;h4 id="1-创建新的-slb">1. 创建新的 SLB&lt;/h4>
&lt;ul>
&lt;li>这里需要创建一个新的 SLB 用来代替自动创建的不符合要求的 SLB。这里可以先私网 SLB 先不绑定弹性IP。&lt;em>&lt;strong>这里要注意的事，新建的 SLB 需要与 k8s集群处于同一 VPC 内，否则在后续会绑定失败&lt;/strong>&lt;/em>。
&lt;img src="https://wx4.sinaimg.cn/large/ad5fbf65gy1g1ma5lxgvdj21ws0s6qa5.jpg" alt="image">&lt;/li>
&lt;li>查看新购买 SLB 的 ID
&lt;img src="https://wx4.sinaimg.cn/large/ad5fbf65gy1g1ma8zuq1gj20sa0hoq4b.jpg" alt="image">&lt;/li>
&lt;/ul>
&lt;h4 id="2-在创建集群后重新绑定-ingress-controller-的-service">2. 在创建集群后重新绑定 &lt;code>ingress-controller&lt;/code> 的 &lt;code>Service&lt;/code>&lt;/h4>
&lt;p>首先需要使用 &lt;code>kubectl&lt;/code> 或者直接在阿里云控制台操作，创建新的 &lt;code>nginx-ingress-svc&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#999;font-style:italic"># nginx ingress service&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#666"> &lt;/span>v1&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">kind&lt;/span>:&lt;span style="color:#666"> &lt;/span>Service&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>nginx-ingress-lb-{new-name}&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">namespace&lt;/span>:&lt;span style="color:#666"> &lt;/span>kube-system&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">labels&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">app&lt;/span>:&lt;span style="color:#666"> &lt;/span>nginx-ingress-lb-{new-name}&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">annotations&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># set loadbalancer to the specified slb id&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">service.beta.kubernetes.io/alicloud-loadbalancer-id&lt;/span>:&lt;span style="color:#666"> &lt;/span>{SLB-ID}&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># set loadbalancer address type to intranet if using private slb instance&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic">#service.beta.kubernetes.io/alicloud-loadbalancer-address-type: intranet&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">service.beta.kubernetes.io/alicloud-loadbalancer-force-override-listeners&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#ed9d13">&amp;#39;true&amp;#39;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic">#service.beta.kubernetes.io/alicloud-loadbalancer-backend-label: node-role.kubernetes.io/ingress=true&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">spec&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">type&lt;/span>:&lt;span style="color:#666"> &lt;/span>LoadBalancer&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># do not route traffic to other nodes&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#999;font-style:italic"># and reserve client ip for upstream&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">externalTrafficPolicy&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#ed9d13">&amp;#34;Local&amp;#34;&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">ports&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">port&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#3677a9">80&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>http&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">targetPort&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#3677a9">80&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>- &lt;span style="color:#6ab825;font-weight:bold">port&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#3677a9">443&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>https&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">targetPort&lt;/span>:&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#3677a9">443&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">selector&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#999;font-style:italic"># select app=ingress-nginx pods&lt;/span>&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">app&lt;/span>:&lt;span style="color:#666"> &lt;/span>ingress-nginx&lt;span style="color:#666">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建成功后，可以进到 SLB 页面查看，可以看到 &lt;code>80&lt;/code> 和 &lt;code>443&lt;/code> 端口的监听已经被添加了
&lt;img src="https://wx4.sinaimg.cn/large/ad5fbf65gy1g1maej57c1j21ru0rwq8b.jpg" alt="image">&lt;/p>
&lt;h4 id="3-绑定符合要求的弹性ip">3. 绑定符合要求的弹性IP&lt;/h4>
&lt;p>确定 SLB 创建成功并且已经成功监听后，这里就可以为 SLB 绑定符合您需求的弹性IP了，这里我们绑定一个按宽带计费2M的弹性IP&lt;/p>
&lt;p>&lt;img src="https://wx4.sinaimg.cn/large/ad5fbf65gy1g1mak2r0p3j207k07mq33.jpg" alt="image">&lt;/p>
&lt;h4 id="4-验证连通性">4. 验证连通性&lt;/h4>
&lt;p>到上面这步，我们的 ingress 入口 SLB 已经创建完成，这里我们验证一下是否联通。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在k8s集群中部署一个 &lt;code>nginx&lt;/code> ，直接在阿里云容器服务控制台操作即可
&lt;img src="https://wx4.sinaimg.cn/large/ad5fbf65gy1g1mant7ec6j21s40qegpr.jpg" alt="image">
这里创建 ingress 路由，&lt;strong>注意：这里的域名需要解析到刚才创建的 SLB 绑定的弹性IP&lt;/strong>
&lt;img src="https://wx4.sinaimg.cn/large/ad5fbf65gy1g1maqf7gdjj21ns0kymz8.jpg" alt="image">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>访问该域名，显示 &lt;code>nginx&lt;/code> 欢迎页，则证明修改成功
&lt;img src="https://wx4.sinaimg.cn/large/ad5fbf65gy1g1mat8srhnj21ak0hmact.jpg" alt="image">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="方法二-使用阿里云容器服务控制台配置">方法二： 使用阿里云容器服务控制台配置&lt;/h3>
&lt;h4 id="1-阿里云容器控制台创建新-service">1. 阿里云容器控制台创建新 &lt;code>service&lt;/code>&lt;/h4>
&lt;ul>
&lt;li>在阿里云容器服务控制台：&lt;code>路由与负载均衡&lt;/code> &amp;ndash;&amp;gt; &lt;code>服务&lt;/code> 点击&lt;code>创建&lt;/code>&lt;/li>
&lt;li>选择 &lt;code>kube-system&lt;/code> 命名空间&lt;/li>
&lt;li>类型选中&lt;code>负载均衡&lt;/code> - &lt;code>内网访问&lt;/code>&lt;/li>
&lt;li>关联 &lt;code>nginx-ingress-controller&lt;/code>&lt;/li>
&lt;li>并添加端口映射&lt;/li>
&lt;li>点击创建&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://wx4.sinaimg.cn/large/ad5fbf65gy1g2g4fwfgevj20i50hsgmp.jpg" alt="image">&lt;/p>
&lt;h4 id="2-进入负载均衡查看-slb-是否创建">2. 进入负载均衡查看 SLB 是否创建&lt;/h4>
&lt;p>可见 SLB 已经成功创建&lt;/p>
&lt;p>&lt;img src="https://wx4.sinaimg.cn/large/ad5fbf65gy1g2g4pb1d45j215303c74r.jpg" alt="image">&lt;/p>
&lt;h4 id="3-绑定符合要求的弹性ip-1">3. 绑定符合要求的弹性IP&lt;/h4>
&lt;p>同方法一&lt;/p>
&lt;h4 id="4验证连通性">4.验证连通性&lt;/h4>
&lt;p>同方法一&lt;/p>
&lt;h3 id="后续操作">后续操作&lt;/h3>
&lt;ul>
&lt;li>在确定新的 SLB 创建成功后，就可以将容器服务自动创建的 SLB 释放了&lt;/li>
&lt;li>删除 &lt;code>kube-system&lt;/code> 中原本绑定的 &lt;code>Service&lt;/code> &lt;strong>（目前版本已经可以关联删除绑定的 SLB 了，不用分开操作）&lt;/strong>&lt;/li>
&lt;li>&lt;strong>这里别忘了，自动创建给API Server 的SLB还是按流量付费的，记得降配&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="后记">后记&lt;/h2>
&lt;p>上面的这些问题和解决方案都属于临时方案，已在阿里的聆听平台提出了上面的问题，相信很快就会有所改进。总的来说，阿里云容器服务在提供优质的 kubernetes 功能，并且只收 ECS 的钱，对于想学习 kubernetes 又没有太多资金的同学也比较友好，直接买按量付费实例，测试完释放即可，不用购买 master 节点，十分良心！&lt;/p></description></item><item><title>Post: 自动合并Kubeconfig，实现多k8s集群切换</title><link>https://guoxudong.io/post/merge-kubeconfig/</link><pubDate>Sun, 17 Mar 2019 10:45:02 +0800</pubDate><guid>https://guoxudong.io/post/merge-kubeconfig/</guid><description>
&lt;h2 id="前言">前言&lt;/h2>
&lt;blockquote>
&lt;p>随着微服务和容器化的深入人心，以及kubernetes已经成为容器编排领域的事实标准，越来越多的公司将自己的服务迁移到kubernetes集群中。而随着kubernetes集群的增加，集群管理的问题就凸显出来，不同的环境存在不同的集群，不同的业务线不同的集群，甚至有些开发人员都有自己的集群。诚然，如果集群是使用公有云如阿里云或华为云的容器服务，可以登录其控制台进行集群管理；或者使用rancher这用的多集群管理工具进行统一的管理。但是在想操作&lt;code>istio&lt;/code>特有的容器资源，或者想使用&lt;code>istioctl&lt;/code>的时候，或者像我一样就是想使用&lt;code>kubectl&lt;/code>命令的同学，这个时候多集群的切换就显的十分重要了。&lt;/p>
&lt;/blockquote>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>&lt;code>kubectl&lt;/code>命令行工具通过&lt;code>kubeconfig&lt;/code>文件的配置来选择集群以及集群的API Server通信的所有信息。&lt;code>kubeconfig&lt;/code>用来保存关于集群，用户，名称空间和身份验证机制的信息。默认情况下&lt;code>kubectl&lt;/code>使用的配置文件名称是在&lt;code>$HOME/.kube&lt;/code>目录下的&lt;code>config&lt;/code>文件，可以通过设置环境变量KUBECONFIG或者&amp;ndash;kubeconfig指定其他的配置文件。详情可看官方文档https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/&lt;/p>
&lt;h2 id="原理">原理&lt;/h2>
&lt;p>使用&lt;code>kubeconfig&lt;/code>文件，您可以组织您的群集，用户和名称空间。 还可以定义上下文以快速轻松地在群集和名称空间之间切换。&lt;/p>
&lt;h3 id="上下文context">上下文(Context)&lt;/h3>
&lt;p>&lt;code>kubeconfig&lt;/code>文件中的上下文元素用于以方便的名称对访问参数进行分组。 每个上下文有三个参数：集群，命名空间和用户。 默认情况下，kubectl命令行工具使用当前上下文中的参数与集群进行通信。可以使用下面的命令设置上下文：&lt;/p>
&lt;pre>&lt;code>kubectl config use-context
&lt;/code>&lt;/pre>
&lt;h3 id="配置内容">配置内容&lt;/h3>
&lt;pre>&lt;code>kubectl config view
&lt;/code>&lt;/pre>
&lt;ol>
&lt;li>如果设置了&lt;code>--kubeconfig&lt;/code>标志，则只使用指定的文件。该标志只允许有一个实例。&lt;/li>
&lt;li>如果环境变量&lt;code>KUBECONFIG&lt;/code>存在，那么就使用该环境变量&lt;code>KUBECONFIG&lt;/code>里面的值，如果不存在该环境变量&lt;code>KUBECONFIG&lt;/code>，那么默认就是使用&lt;code>$HOME/.kube/config&lt;/code>文件。&lt;/li>
&lt;/ol>
&lt;h3 id="kubeconfig内容">&lt;code>kubeconfig&lt;/code>内容&lt;/h3>
&lt;p>从下面kubeconfig文件的配置来看集群、用户、上下文、当前上下文的关系就比较明显了。&lt;/p>
&lt;pre>&lt;code>apiVersion: v1
kind: Config
preferences: {}
clusters:
- cluster:
name: {cluster-name}
users:
- name: {user-name}
contexts:
- context:
cluster: {cluster-name}
user: {user-name}
name: {context-name}
current-context: {context-name}
&lt;/code>&lt;/pre>
&lt;h2 id="为何要自动合并">为何要自动合并&lt;/h2>
&lt;p>在日常的工作中，如果我们需要操作多个集群，会得到多个kubeconfig配置文件。一般的kubeconfig文件都是yaml格式的，但是也有少部分的集群kubeconfig时已json文件的形式给出的（比如华为云的=。=），比如我们公司再阿里云、华为云和自建环境上均存在kubernetes集群，平时操作要在多集群之间切换，这也就催生了我写这个工具（其实就是一个脚本）的动机。&lt;/p>
&lt;h2 id="自动合并生成kubeconfig">自动合并生成kubeconfig&lt;/h2>
&lt;p>众所周知，yaml是一种直观的能够被电脑识别的数据序列化格式，是一个可读性高并且容易被人类阅读的语言和json相比（没有格式化之前）可读性更强。而我这个工具并不是很关心kubeconfig的格式，只要将想要合并的kubeconfig放入指定文件即可。&lt;/p>
&lt;p>GitHub：https://github.com/sunny0826/mergeKubeConfig&lt;/p>
&lt;h3 id="适用环境">适用环境&lt;/h3>
&lt;ul>
&lt;li>需要在终端使用命令行管理多集群&lt;/li>
&lt;li>kubernetes集群中安装了istio，需要使用&lt;code>istioctl&lt;/code>命令，但是集群节点并没有安装&lt;code>istioctl&lt;/code>，需要在本地终端操作&lt;/li>
&lt;li>不愿频繁编辑.kube目录中的config文件的同学&lt;/li>
&lt;/ul>
&lt;h3 id="准备工作">准备工作&lt;/h3>
&lt;ul>
&lt;li>Python环境：2.7或者3均可&lt;/li>
&lt;li>需要依赖包：&lt;code>PyYAML&lt;/code>&lt;/li>
&lt;/ul>
&lt;h3 id="开始使用">开始使用&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>安装依赖：&lt;/p>
&lt;pre>&lt;code> pip install PyYAML
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>运行脚本&lt;/p>
&lt;ul>
&lt;li>
&lt;p>默认运行方式，kubeconfig文件放入&lt;code>configfile&lt;/code>文件,注意删掉作为示例的两个文件&lt;/p>
&lt;pre>&lt;code> python merge.py
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>自定义kubeconfig文件目录&lt;/p>
&lt;pre>&lt;code> python merge.py -d {custom-dir}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="运行后操作">运行后操作&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>将生成的config文件放入.kube目录中&lt;/p>
&lt;pre>&lt;code> cp config ~/.kube
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>查看所有的可使用的kubernetes集群角色&lt;/p>
&lt;pre>&lt;code> kubectl config get-contexts
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>更多关于kubernetes配置文件操作&lt;/p>
&lt;pre>&lt;code> kubectl config --help
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>切换kubernetes配置&lt;/p>
&lt;pre>&lt;code> kubectl config use-context {your-contexts}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>在使用kubernetes初期，在多集群之间我一直是频繁的切换&lt;code>.kube/config&lt;/code>文件来达到切换操作集群的目的。这也导致了我的&lt;code>.kube&lt;/code>目录中存在这多个类似于&lt;code>al_test_config.bak&lt;/code>、&lt;code>al_prod_config.bak&lt;/code>、&lt;code>hw_test_config.bak&lt;/code>的文件，本地环境已经自建环境，在集群切换的时候十分头疼。而后来使用&lt;code>--kubeconfig&lt;/code>来进行切换集群，虽然比之前的方法要方便很多，但是并不十分优雅。这个简单的小工具一举解决了我的文件，对于我这个&lt;code>kubectl&lt;/code>重度依赖者来说十分重要。&lt;/p></description></item><item><title>Post: 解决kubernetes中ingress-nginx配置问题</title><link>https://guoxudong.io/post/k8s-ingress-config/</link><pubDate>Wed, 06 Mar 2019 14:42:05 +0800</pubDate><guid>https://guoxudong.io/post/k8s-ingress-config/</guid><description>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>随着公司容器化的深入，越来越多的服务陆续迁移到kubernetes集群中，有些问题在测试环境并未凸显，但是在生产环境中这些问题就显得格外的扎眼。这里就对实践中kubernetes集群中的7层负载均衡器ingress遇到的问题进行总结。&lt;/p>
&lt;h2 id="https负载均衡器-ingress">HTTP(S)负载均衡器-ingress&lt;/h2>
&lt;p>Ingress是kubernetes API的标准资源类型之一，其本质就是一组基于DNS名称(host)或URL路径把请求转发至指定的Service资源的规则，&lt;strong>用于将集群外的请求流量转发至集群内部完成服务发布&lt;/strong>。&lt;/p>
&lt;p>Ingress控制器(Ingress Controller)可以由任何具有反向代理(HTTP/HTTPS)功能的服务程序实现，如Nginx、Envoy、HAProxy、Vulcand和Traefik等。Ingress控制器本身也作为Pod对象与被代理的运行为Pod资源的应用运行于同一网络中。我们在这里选择了NGINX Ingress Controller，由于对NGINX的配置较为熟悉，同时我们使用的kubernetes是阿里云的容器服务，构建集群的时候，容器服务会自带NGINX Ingress Controller。&lt;/p>
&lt;p>&lt;img src="http://wx2.sinaimg.cn/large/ad5fbf65ly1g0t3yj7wecj20w50doab9.jpg" alt="image">&lt;/p>
&lt;h2 id="根据实际情况ingress调优">根据实际情况Ingress调优&lt;/h2>
&lt;h3 id="1-解决400-request-header-or-cookie-too-large问题">1. 解决400 Request Header Or Cookie Too Large问题&lt;/h3>
&lt;h2 id="preview_only-false">image:
caption: &amp;ldquo;Image from: &lt;a href="https://www.pexels.com">&lt;strong>Pexels&lt;/strong>&lt;/a>&amp;rdquo;
focal_point: &amp;quot;&amp;quot;
preview_only: false&lt;/h2>
&lt;h4 id="现象">现象&lt;/h4>
&lt;p>微信小程序需要调用后端接口，需要在header中传一段很长的token参数，直接使用浏览器访问该端口可以访问通，但是在加上token访问之后，会报“400 Request Header Or Cookie Too Large”&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-html" data-lang="html">&amp;lt;&lt;span style="color:#6ab825;font-weight:bold">html&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#6ab825;font-weight:bold">head&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#6ab825;font-weight:bold">title&lt;/span>&amp;gt;400 Request Header Or Cookie Too Large&amp;lt;/&lt;span style="color:#6ab825;font-weight:bold">title&lt;/span>&amp;gt;
&amp;lt;/&lt;span style="color:#6ab825;font-weight:bold">head&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#6ab825;font-weight:bold">body&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#6ab825;font-weight:bold">center&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#6ab825;font-weight:bold">h1&lt;/span>&amp;gt;400 Bad Request&amp;lt;/&lt;span style="color:#6ab825;font-weight:bold">h1&lt;/span>&amp;gt;
&amp;lt;/&lt;span style="color:#6ab825;font-weight:bold">center&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#6ab825;font-weight:bold">center&lt;/span>&amp;gt;Request Header Or Cookie Too Large&amp;lt;/&lt;span style="color:#6ab825;font-weight:bold">center&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#6ab825;font-weight:bold">hr&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#6ab825;font-weight:bold">center&lt;/span>&amp;gt;nginx/1.15.6&amp;lt;/&lt;span style="color:#6ab825;font-weight:bold">center&lt;/span>&amp;gt;
&amp;lt;/&lt;span style="color:#6ab825;font-weight:bold">body&lt;/span>&amp;gt;
&amp;lt;/&lt;span style="color:#6ab825;font-weight:bold">html&lt;/span>&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="问题定位">问题定位&lt;/h4>
&lt;p>直接修改Service使用nodeport的形式访问，则没有报错，初步定位需要在ingress中nginx配置客户端的请求头，进入Ingress Controller的Pod查询配置，果然是请求头空间不足。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ cat nginx.conf | grep client_header_buffer_size
client_header_buffer_size 1k;
$ cat nginx.conf | grep large_client_header_buffers
large_client_header_buffers &lt;span style="color:#3677a9">4&lt;/span> 8k;
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="解决方法">解决方法&lt;/h4>
&lt;p>在ingress中添加注释&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="color:#6ab825;font-weight:bold">nginx.ingress.kubernetes.io/server-snippet:&lt;/span> &lt;span style="color:#ed9d13">client_header_buffer_size&lt;/span> &lt;span style="color:#3677a9">2046k&lt;/span>;
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="preview_only-false-1">image:
caption: &amp;ldquo;Image from: &lt;a href="https://www.pexels.com">&lt;strong>Pexels&lt;/strong>&lt;/a>&amp;rdquo;
focal_point: &amp;quot;&amp;quot;
preview_only: false&lt;/h2>
&lt;p>&lt;strong>Server snippet&lt;/strong>&lt;br>Using the annotation &lt;code>nginx.ingress.kubernetes.io/server-snippet&lt;/code> it is possible to add custom configuration in the server configuration block.
&lt;br>该注释是将自定义配置加入nginx的server配置中&lt;/p>
&lt;h2 id="preview_only-false-2">image:
caption: &amp;ldquo;Image from: &lt;a href="https://www.pexels.com">&lt;strong>Pexels&lt;/strong>&lt;/a>&amp;rdquo;
focal_point: &amp;quot;&amp;quot;
preview_only: false&lt;/h2>
&lt;h3 id="2-解决请求超时问题">2. 解决请求超时问题&lt;/h3>
&lt;h4 id="现象-1">现象&lt;/h4>
&lt;p>有一个数据导出功能，需要将大量数据进行处理，然后以Excel格式返回，在导出一个大约3W条数据的时候，出现访问超时情况。&lt;/p>
&lt;p>&lt;img src="https://ws2.sinaimg.cn/mw690/ad5fbf65ly1g0ubdwwzo5j21b30bjaat.jpg" alt="image">&lt;/p>
&lt;h4 id="解决方法-1">解决方法&lt;/h4>
&lt;p>调整proxy_read_timeout，连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理
在ingress中添加注释&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="color:#6ab825;font-weight:bold">nginx.ingress.kubernetes.io/proxy-read-timeout:&lt;/span> &lt;span style="color:#3677a9">600&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>这里需要注意的事该注释的value需要时number类型，不能加s，否则将不生效&lt;/p>
&lt;/blockquote>
&lt;h3 id="3-增加白名单">3. 增加白名单&lt;/h3>
&lt;h4 id="现象-2">现象&lt;/h4>
&lt;p>在实际的使用中，会有一部分应用需要设置只可以在办公场地的网络使用，之前使用阿里云 SLB 的时候可以针对端口进行访问控制，但是现在走 ingress ，都是从80 or 443端口进，所以需要在 ingress 设置&lt;/p>
&lt;h4 id="解决方法-2">解决方法&lt;/h4>
&lt;blockquote>
&lt;p>&lt;strong>Whitelist source range&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>You can specify allowed client IP source ranges through the nginx.ingress.kubernetes.io/whitelist-source-range annotation. The value is a comma separated list of CIDRs, e.g. 10.0.0.0/24,172.10.0.1.&lt;/p>
&lt;/blockquote>
&lt;p>在 ingress 里配置 &lt;code>nginx.ingress.kubernetes.io/whitelist-source-range&lt;/code> ，如有多个ip段，用逗号分隔即可&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="color:#6ab825;font-weight:bold">nginx.ingress.kubernetes.io/whitelist-source-range:&lt;/span> &lt;span style="color:#3677a9">10&lt;/span>&lt;span style="color:#ed9d13">.0.0.0/24&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果想全局适用，可以在阿里云 SLB 里操作，也可以将该配置加入到 &lt;code>NGINX ConfigMap&lt;/code> 中。&lt;/p>
&lt;h2 id="preview_only-false-3">image:
caption: &amp;ldquo;Image from: &lt;a href="https://www.pexels.com">&lt;strong>Pexels&lt;/strong>&lt;/a>&amp;rdquo;
focal_point: &amp;quot;&amp;quot;
preview_only: false&lt;/h2>
&lt;p>根据工作中遇到的实际问题，持续更新中&amp;hellip;&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>使用NGINX ingress controller的好处就是对于nginx配置相对比较熟悉，性能也不差。相关nginx配置的对应的ingress可以在 &lt;a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/">https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/&lt;/a> 上查到。&lt;/p></description></item><item><title>Post: Pod质量服务类别(QoS)</title><link>https://guoxudong.io/post/k8s-qos/</link><pubDate>Mon, 04 Mar 2019 19:18:13 +0800</pubDate><guid>https://guoxudong.io/post/k8s-qos/</guid><description>
&lt;blockquote>
&lt;p>根据Pod对象的requests和limits属性，kubernetes将Pod对象归类到BestEffort、Burstable和Guaranteed三个服务质量（Quality of Service，QoS）类别。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>Guaranteed
&lt;ul>
&lt;li>cpu:requests=limits&lt;/li>
&lt;li>memory:requests=limits&lt;/li>
&lt;li>这类Pod具有最高优先级&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Burstable
&lt;ul>
&lt;li>至少一个容器设置了cpu或内存资源的requests&lt;/li>
&lt;li>这类Pod具有中等优先级&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>BestEffort
&lt;ul>
&lt;li>未有任何一个容器设置requests或limits属性&lt;/li>
&lt;li>这类Pod具有最低优先级&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="http://ww1.sinaimg.cn/large/ad5fbf65ly1g0rv2ipzqkj20hx0edmx8.jpg" alt="">&lt;/p>
&lt;p>同级别优先级的Pod资源在OOM时，与自身的requests属性相比，其内存占用比例最大的Pod对象将被首先杀死。如上图同属Burstable类别的Pod A将先于Pod B被杀死，虽然其内存用量小，但与自身的requests值相比，它的占用比例95%要大于Pod B的80%。&lt;/p></description></item><item><title>Post: 为ingress配置SSL证书，实现HTTPS访问</title><link>https://guoxudong.io/post/https-ingress/</link><pubDate>Sat, 29 Dec 2018 21:28:13 +0800</pubDate><guid>https://guoxudong.io/post/https-ingress/</guid><description>
&lt;blockquote>
&lt;p>devops平台率先在公司内使用kubernetes集群提供后端服务，但是由于之前一直处于探索阶段，所以使用的事http的方式提供后端服务，但是在开发统一入口后，出现了访问HTTPS页面的跨域问题，由此引出了后端服务配置SSL证书的问题&lt;/p>
&lt;/blockquote>
&lt;h1 id="使用rancher配置ssl证书">使用rancher配置SSL证书&lt;/h1>
&lt;h2 id="下载ssl证书文件">下载SSL证书文件&lt;/h2>
&lt;p>首先需要获得SSL证书文件，可以直接在阿里云SSL证书管理控制台下载&lt;/p>
&lt;p>选中需要下载证书，选择下载nginx证书
&lt;img src="https://guoxudong.io/images/source/zhengshu.png" alt="image">&lt;/p>
&lt;h2 id="将证书上传项目">将证书上传项目&lt;/h2>
&lt;p>打开rancher，选择要使用证书的项目，点击资源中的证书&lt;/p>
&lt;h2 id="将证书上传项目-1">将证书上传项目&lt;/h2>
&lt;p>打开rancher，选择要使用证书的项目，点击资源中的证书
&lt;img src="https://guoxudong.io/images/source/https-1.png" alt="image">
添加证书，点击从文件上传
&lt;img src="https://guoxudong.io/images/source/https-2.png" alt="image">
上传证书文件中的秘钥和证书，点击保存即可&lt;/p>
&lt;h1 id="使用yaml上传证书">使用yaml上传证书&lt;/h1>
&lt;p>这个证书的原理其实是在相应的命名空间创建了一个包含证书信息的secrets&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#6ab825;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#666"> &lt;/span>v1&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">data&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">tls.crt&lt;/span>:&lt;span style="color:#666"> &lt;/span>{私钥}&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">tls.key&lt;/span>:&lt;span style="color:#666"> &lt;/span>{证书}&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">kind&lt;/span>:&lt;span style="color:#666"> &lt;/span>Secret&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">name&lt;/span>:&lt;span style="color:#666"> &lt;/span>keking-cn&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666"> &lt;/span>&lt;span style="color:#6ab825;font-weight:bold">namespace&lt;/span>:&lt;span style="color:#666"> &lt;/span>devops-plat&lt;span style="color:#666">
&lt;/span>&lt;span style="color:#666">&lt;/span>&lt;span style="color:#6ab825;font-weight:bold">type&lt;/span>:&lt;span style="color:#666"> &lt;/span>kubernetes.io/tls&lt;span style="color:#666">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在kubernetes上运行该yaml即可&lt;/p>
&lt;h1 id="rancher中证书绑定">rancher中证书绑定&lt;/h1>
&lt;p>选中需要绑定证书的ingress，点击编辑，选中证书，保存即可（由于ingress-controller中没有绑定默认证书，所以这里不能选中默认）
&lt;img src="https://guoxudong.io/images/source/https-3.png" alt="image">
保存完毕，证书即可生效&lt;/p></description></item><item><title>Post: kubernetes集群概述</title><link>https://guoxudong.io/post/k8s-topo/</link><pubDate>Wed, 03 Oct 2018 12:18:13 +0800</pubDate><guid>https://guoxudong.io/post/k8s-topo/</guid><description>
&lt;blockquote>
&lt;p>随着2017年AWS，Azure和阿里云相继在其原有容器服务上新增了对kubernetes的支持，而Docker官网也在同年10月宣布同时支持Swarm好kubernetes容器编排系统。kubernetes俨然已成为容器编排领域事实上的标准，而2018年更是各大公司相继将服务迁移到kubernetes上，而kubernetes则以惊人更新速度，保持着每个季度发布一个大版本的速度高速发展着。&lt;/p>
&lt;/blockquote>
&lt;h1 id="kubernetes特征">kubernetes特征&lt;/h1>
&lt;p>kubernetes是一种在一组主机上运行和协同容器化应用程序的系统，旨在提供可预测性、可拓展性与高可用性的方法来完全管理容器化应用和服务的生命周期平台。用户可以定义应用程序的运行方式，以及与其他应用程序或外部世界交互的途径，并能实现服务的扩容和缩容，执行平滑滚动更新，以及在不同版本的应用程序之间调度流量以测试功能或回滚有问题的部署。kubernetes提供了接口和可组合帆软平台原语，使得用户能够以高度的灵活性和可靠性定义及管理应用程序。&lt;/p>
&lt;h1 id="kubernetes组件及网络通信">kubernetes组件及网络通信&lt;/h1>
&lt;p>kubernetes集群的客户端可以分为两类：API Server客户端和应用程序（运行为Pod中的容器）客户端。
&lt;img src="https://guoxudong.io/images/source/kubernetes-topo.png" alt="image">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>第一类客户端通常包含用户和Pod对象两种，它们通过API Server访问kubernetes集群完成管理任务，例如，管理集群上的各种资源对象。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第二类客户端一般也包含人类用户和Pod对象两种，它们的访问目标是Pod上运行于容器中的应用程序提供的各种具体的服务，如redis或nginx等，不过，这些访问请求通常要经由Service或Ingress资源对象进行。另外，第二类客户端的访问目标对象的操作要经由第一类客户端创建和配置完成后才进行。&lt;/p>
&lt;p>访问API Server时，人类用户一般借助于命令行工具kubectl或图形UI（例如kubernetes dashboard）进行，也通过编程接口进行访问，包括REST API。访问Pod中的应用时，其访问方式要取决于Pod中的应用程序，例如，对于运行Nginx容器的Pod来说，其最常用工具就是浏览器。&lt;/p>
&lt;p>管理员（开发人员或运维人员）使用kubernetes集群的常见操作包括通过控制器创建Pod，在Pod的基础上创建Service供第二类客户端访问，更新Pod中的应用版本（更新和回滚）以及对应用规模进行扩容或缩容等，另外还有集群附件管理、存储卷管理、网络及网络策略管理、资源管理和安全管理等。&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Post: 容器技术概述</title><link>https://guoxudong.io/post/con-in/</link><pubDate>Thu, 30 Aug 2018 18:45:22 +0800</pubDate><guid>https://guoxudong.io/post/con-in/</guid><description>
&lt;h1 id="背景">背景&lt;/h1>
&lt;blockquote>
&lt;p>自从微服务（Microservice）的出现，出于业务的需要，IT应用模型不断的变革。开发模式从瀑布式到敏捷开发；开发、运维和测试互相配合的devops思想；应用程序架构从单体模型到分层模型再到微服务；部署方式也从面向物理机到虚拟键再到容器；应用程序的基础架构从自建机房到托管再到云计算，等等。这些变革使得IT技术应用的效率大大提升，同时却以&lt;strong>更低的成本交付更高质量的产品&lt;/strong>。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>尤其是以Docker为代表的容器技术的出现，终结了devops中交付和部署环节因环节、配置及程序本身的不同而造成的动辄几种甚至十几种部署配置的困境，将它们统一在容器镜像（image）之上。这就是我在工作中遇到最先遇到的困境，同时也是我开始研究容器技术的契机。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>如今，越来越多的企业或组织开始开始选择以镜像文件为交付载体。容器镜像之内直接包含了应用程序及其依赖的系统环境、库、基础程序等，从而能够在容器引擎上直接运行。&lt;/p>
&lt;/blockquote>
&lt;h1 id="容器技术概述">容器技术概述&lt;/h1>
&lt;p>容器是一种轻量级、可移植、自包含的软件打包技术，它使得应用程序可以在几乎任何地方以相同的方式运行。&lt;/p>
&lt;p>容器有应用程序本身和它的环境依赖（库和其他应用程序）两部分组成，并在宿主机（Host）操作系统的用户空间中运行，但与操作系统的其他进程互相隔离，他们的实现机制有别于VMWare、KVM、Xen等实现方案的虚拟化技术。容器与虚拟机的对比关系如下图
&lt;img src="https://guoxudong.io/images/source/vs.png" alt="image">
由于同一个宿主机上的所有容器都共享其底层操作系统（内核空间），这就使得容器在体积上要比传统的虚拟机小很多。另外，启动容器无须启动整个操作系统，所以容器部署和启动的速度更快，开销更小，也更容易迁移。事实上，容器赋予了应用程序超强的可移植能力。&lt;/p>
&lt;h1 id="容器技术的优势">容器技术的优势&lt;/h1>
&lt;ul>
&lt;li>开发方面：“一次构建、到处运行”（Build Once, Run Anywhere）。容器意味着环境隔离和可重复性，开发人员只需为应用创建一个运行环境，并将其打包成容器便可在各种部署环境上运行，并与它所在的宿主机环境隔离。&lt;/li>
&lt;li>运维方面：“一次配置，运行所以”（Configure Once, Run Anything）。一旦配置好标准的容器运行时环境，服务器就可以运行任何容器，这使得运维人员的工作变得更高效、一致和可重复。容器消除了开发、测试、生产环境的不一致性。&lt;/li>
&lt;/ul></description></item></channel></rss>